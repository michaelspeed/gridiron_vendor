"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type Account {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  currentBalance: Float!
  totalVolumeBalance: Float!
  vendor: Vendor!
}

input AccountAggregateFilter {
  and: [AccountAggregateFilter!]
  or: [AccountAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type AccountAggregateResponse {
  count: AccountCountAggregate
  min: AccountMinAggregate
  max: AccountMaxAggregate
}

type AccountCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type AccountDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  currentBalance: Float
  totalVolumeBalance: Float
}

input AccountFilter {
  and: [AccountFilter!]
  or: [AccountFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type AccountMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type AccountMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input AccountSort {
  field: AccountSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AccountSortFields {
  id
  createdAt
  updatedAt
  deletedAt
}

input AccountSubscriptionFilter {
  and: [AccountSubscriptionFilter!]
  or: [AccountSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type Address {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  fullName: String!
  addressLine: String!
  city: String!
  state: String!
  landmark: String!
  postalCode: String!
  phoneNumber: String!
  alternatePhoneNumber: String!
  defaultShippingAddress: Boolean!
  defaultBillingAddress: Boolean!
  addressType: AddressType!
  user: User
}

input AddressAggregateFilter {
  and: [AddressAggregateFilter!]
  or: [AddressAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fullName: StringFieldComparison
  addressLine: StringFieldComparison
  city: StringFieldComparison
  state: StringFieldComparison
  landmark: StringFieldComparison
  postalCode: StringFieldComparison
  phoneNumber: StringFieldComparison
  alternatePhoneNumber: StringFieldComparison
  defaultShippingAddress: BooleanFieldComparison
  defaultBillingAddress: BooleanFieldComparison
  addressType: AddressTypeFilterComparison
}

type AddressAggregateResponse {
  count: AddressCountAggregate
  min: AddressMinAggregate
  max: AddressMaxAggregate
}

type AddressCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  fullName: Int
  addressLine: Int
  city: Int
  state: Int
  landmark: Int
  postalCode: Int
  phoneNumber: Int
  alternatePhoneNumber: Int
  defaultShippingAddress: Int
  defaultBillingAddress: Int
  addressType: Int
}

input AddressDeleteFilter {
  and: [AddressDeleteFilter!]
  or: [AddressDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fullName: StringFieldComparison
  addressLine: StringFieldComparison
  city: StringFieldComparison
  state: StringFieldComparison
  landmark: StringFieldComparison
  postalCode: StringFieldComparison
  phoneNumber: StringFieldComparison
  alternatePhoneNumber: StringFieldComparison
  defaultShippingAddress: BooleanFieldComparison
  defaultBillingAddress: BooleanFieldComparison
  addressType: AddressTypeFilterComparison
}

type AddressDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  addressType: AddressType
}

input AddressFilter {
  and: [AddressFilter!]
  or: [AddressFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fullName: StringFieldComparison
  addressLine: StringFieldComparison
  city: StringFieldComparison
  state: StringFieldComparison
  landmark: StringFieldComparison
  postalCode: StringFieldComparison
  phoneNumber: StringFieldComparison
  alternatePhoneNumber: StringFieldComparison
  defaultShippingAddress: BooleanFieldComparison
  defaultBillingAddress: BooleanFieldComparison
  addressType: AddressTypeFilterComparison
}

type AddressMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  addressType: AddressType
}

type AddressMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  addressType: AddressType
}

input AddressSort {
  field: AddressSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AddressSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  fullName
  addressLine
  city
  state
  landmark
  postalCode
  phoneNumber
  alternatePhoneNumber
  defaultShippingAddress
  defaultBillingAddress
  addressType
}

input AddressSubscriptionFilter {
  and: [AddressSubscriptionFilter!]
  or: [AddressSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fullName: StringFieldComparison
  addressLine: StringFieldComparison
  city: StringFieldComparison
  state: StringFieldComparison
  landmark: StringFieldComparison
  postalCode: StringFieldComparison
  phoneNumber: StringFieldComparison
  alternatePhoneNumber: StringFieldComparison
  defaultShippingAddress: BooleanFieldComparison
  defaultBillingAddress: BooleanFieldComparison
  addressType: AddressTypeFilterComparison
}

enum AddressType {
  HOME
  WORK
}

input AddressTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: AddressType
  neq: AddressType
  gt: AddressType
  gte: AddressType
  lt: AddressType
  lte: AddressType
  like: AddressType
  notLike: AddressType
  iLike: AddressType
  notILike: AddressType
  in: [AddressType!]
  notIn: [AddressType!]
}

input AddressUpdateFilter {
  and: [AddressUpdateFilter!]
  or: [AddressUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fullName: StringFieldComparison
  addressLine: StringFieldComparison
  city: StringFieldComparison
  state: StringFieldComparison
  landmark: StringFieldComparison
  postalCode: StringFieldComparison
  phoneNumber: StringFieldComparison
  alternatePhoneNumber: StringFieldComparison
  defaultShippingAddress: BooleanFieldComparison
  defaultBillingAddress: BooleanFieldComparison
  addressType: AddressTypeFilterComparison
}

type Administrator {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  firstName: String!
  lastName: String!
  emailAddress: String!
  type: AdministratorEnum!
  user: User!
}

type AdministratorDto {
  user: User!
  token: String!
  store: Store
  type: AdministratorResponseType!
}

enum AdministratorEnum {
  SUPERADMIN
  STAFF
}

enum AdministratorResponseType {
  BASIC
  ADMIN
  VENDOR
  BOTH
}

type Asset {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  name: String!
  type: AssetType!
  mimeType: String!
  width: Float!
  height: Float!
  fileSize: Float!
  source: String!
  preview: String!
  focalPoint: JSONObject!
  featureds(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  productAssets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductAssetFilter = {}

    """Specify to sort results."""
    sorting: [ProductAssetSort!] = []
  ): [ProductAsset!]!
  store: Store
  menu: Menu
  collection: Collection
  featuredsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): AssetFeaturedsAggregateResponse!
  productAssetsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAssetAggregateFilter
  ): AssetProductAssetsAggregateResponse!
}

input AssetAggregateFilter {
  and: [AssetAggregateFilter!]
  or: [AssetAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  type: AssetTypeFilterComparison
  mimeType: StringFieldComparison
  width: NumberFieldComparison
  height: NumberFieldComparison
  fileSize: NumberFieldComparison
  source: StringFieldComparison
  preview: StringFieldComparison
}

type AssetAggregateResponse {
  count: AssetCountAggregate
  sum: AssetSumAggregate
  avg: AssetAvgAggregate
  min: AssetMinAggregate
  max: AssetMaxAggregate
}

type AssetAvgAggregate {
  width: Float
  height: Float
  fileSize: Float
}

type AssetCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  type: Int
  mimeType: Int
  width: Int
  height: Int
  fileSize: Int
  source: Int
  preview: Int
}

input AssetDeleteFilter {
  and: [AssetDeleteFilter!]
  or: [AssetDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  type: AssetTypeFilterComparison
  mimeType: StringFieldComparison
  width: NumberFieldComparison
  height: NumberFieldComparison
  fileSize: NumberFieldComparison
  source: StringFieldComparison
  preview: StringFieldComparison
}

type AssetDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  type: AssetType
  mimeType: String
  width: Float
  height: Float
  fileSize: Float
  source: String
  preview: String
  focalPoint: JSONObject
}

type AssetFeaturedsAggregateResponse {
  count: AssetFeaturedsCountAggregate
  min: AssetFeaturedsMinAggregate
  max: AssetFeaturedsMaxAggregate
}

type AssetFeaturedsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type AssetFeaturedsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type AssetFeaturedsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

input AssetFilter {
  and: [AssetFilter!]
  or: [AssetFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  type: AssetTypeFilterComparison
  mimeType: StringFieldComparison
  width: NumberFieldComparison
  height: NumberFieldComparison
  fileSize: NumberFieldComparison
  source: StringFieldComparison
  preview: StringFieldComparison
}

type AssetMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  type: AssetType
  mimeType: String
  width: Float
  height: Float
  fileSize: Float
  source: String
  preview: String
}

type AssetMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  type: AssetType
  mimeType: String
  width: Float
  height: Float
  fileSize: Float
  source: String
  preview: String
}

type AssetProductAssetsAggregateResponse {
  count: AssetProductAssetsCountAggregate
  min: AssetProductAssetsMinAggregate
  max: AssetProductAssetsMaxAggregate
}

type AssetProductAssetsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type AssetProductAssetsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type AssetProductAssetsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input AssetSort {
  field: AssetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AssetSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  name
  type
  mimeType
  width
  height
  fileSize
  source
  preview
}

input AssetSubscriptionFilter {
  and: [AssetSubscriptionFilter!]
  or: [AssetSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  type: AssetTypeFilterComparison
  mimeType: StringFieldComparison
  width: NumberFieldComparison
  height: NumberFieldComparison
  fileSize: NumberFieldComparison
  source: StringFieldComparison
  preview: StringFieldComparison
}

type AssetSumAggregate {
  width: Float
  height: Float
  fileSize: Float
}

enum AssetType {
  IMAGE
  VIDEO
  BINARY
}

input AssetTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: AssetType
  neq: AssetType
  gt: AssetType
  gte: AssetType
  lt: AssetType
  lte: AssetType
  like: AssetType
  notLike: AssetType
  iLike: AssetType
  notILike: AssetType
  in: [AssetType!]
  notIn: [AssetType!]
}

type BillingAgreement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  value: Float!
  type: BillingAgreementEnum!
  state: BillingAgreementState!
  variant: ProductVariant!
  collection: Collection
  store: Store!
  request: [BillingAgreementRequest!]!
}

input BillingAgreementAggregateFilter {
  and: [BillingAgreementAggregateFilter!]
  or: [BillingAgreementAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  value: NumberFieldComparison
}

enum BillingAgreementEnum {
  PLANBASE
  COLLECTIONBASE
  COMISSIONBASE
  PRODCOMMISSION
}

input BillingAgreementFilter {
  and: [BillingAgreementFilter!]
  or: [BillingAgreementFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  value: NumberFieldComparison
  store: BillingAgreementFilterStoreFilter
  variant: BillingAgreementFilterProductVariantFilter
}

input BillingAgreementFilterProductVariantFilter {
  and: [BillingAgreementFilterProductVariantFilter!]
  or: [BillingAgreementFilterProductVariantFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
}

input BillingAgreementFilterStoreFilter {
  and: [BillingAgreementFilterStoreFilter!]
  or: [BillingAgreementFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type BillingAgreementRequest {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  value: Float!
  state: BillingAgreementState!
}

input BillingAgreementSort {
  field: BillingAgreementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum BillingAgreementSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  value
}

enum BillingAgreementState {
  APPROVED
  PENDING
  REJECTED
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

type Cancellation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Float!
  keeping: StockKeeping!
}

input CancellationAggregateFilter {
  and: [CancellationAggregateFilter!]
  or: [CancellationAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type CancellationAggregateResponse {
  count: CancellationCountAggregate
  sum: CancellationSumAggregate
  avg: CancellationAvgAggregate
  min: CancellationMinAggregate
  max: CancellationMaxAggregate
}

type CancellationAvgAggregate {
  quantity: Float
}

type CancellationCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

input CancellationDeleteFilter {
  and: [CancellationDeleteFilter!]
  or: [CancellationDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type CancellationDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input CancellationFilter {
  and: [CancellationFilter!]
  or: [CancellationFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type CancellationMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type CancellationMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input CancellationSort {
  field: CancellationSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CancellationSortFields {
  id
  createdAt
  updatedAt
  quantity
}

input CancellationSubscriptionFilter {
  and: [CancellationSubscriptionFilter!]
  or: [CancellationSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type CancellationSumAggregate {
  quantity: Float
}

input CancellationUpdateFilter {
  and: [CancellationUpdateFilter!]
  or: [CancellationUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type Cart {
  id: ID!
  items: [CartItem!]!
  user: User
}

type CartItem {
  id: ID!
  quantity: Float!
  cart: Cart!
  variant: ProductVariant!
  store: Store!
  price: ProductVariantPrice!
}

input CartItemAggregateFilter {
  and: [CartItemAggregateFilter!]
  or: [CartItemAggregateFilter!]
  id: IDFilterComparison
}

input CartItemFilter {
  and: [CartItemFilter!]
  or: [CartItemFilter!]
  id: IDFilterComparison
}

input CartItemSort {
  field: CartItemSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CartItemSortFields {
  id
}

type CartPriceRules {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  priceType: PricePromoType!
  value: Float!
  collection: Collection
}

input CartPriceRulesAggregateFilter {
  and: [CartPriceRulesAggregateFilter!]
  or: [CartPriceRulesAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
}

type CartPriceRulesAggregateResponse {
  count: CartPriceRulesCountAggregate
  sum: CartPriceRulesSumAggregate
  avg: CartPriceRulesAvgAggregate
  min: CartPriceRulesMinAggregate
  max: CartPriceRulesMaxAggregate
}

type CartPriceRulesAvgAggregate {
  value: Float
}

type CartPriceRulesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  priceType: Int
  value: Int
}

input CartPriceRulesDeleteFilter {
  and: [CartPriceRulesDeleteFilter!]
  or: [CartPriceRulesDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
}

type CartPriceRulesDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
}

input CartPriceRulesFilter {
  and: [CartPriceRulesFilter!]
  or: [CartPriceRulesFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
}

type CartPriceRulesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
}

type CartPriceRulesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
}

input CartPriceRulesSort {
  field: CartPriceRulesSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CartPriceRulesSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  priceType
  value
}

input CartPriceRulesSubscriptionFilter {
  and: [CartPriceRulesSubscriptionFilter!]
  or: [CartPriceRulesSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
}

type CartPriceRulesSumAggregate {
  value: Float
}

input CartPriceRulesUpdateFilter {
  and: [CartPriceRulesUpdateFilter!]
  or: [CartPriceRulesUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
}

type Channel {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  code: String!
  token: String!
  defaultLanguageCode: LanguageCode!
  currencyCode: CurrencyCode!
  pricesIncludeTax: Boolean!
}

input ChannelAggregateFilter {
  and: [ChannelAggregateFilter!]
  or: [ChannelAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  code: StringFieldComparison
  token: StringFieldComparison
  defaultLanguageCode: LanguageCodeFilterComparison
  currencyCode: CurrencyCodeFilterComparison
  pricesIncludeTax: BooleanFieldComparison
}

type ChannelAggregateResponse {
  count: ChannelCountAggregate
  min: ChannelMinAggregate
  max: ChannelMaxAggregate
}

type ChannelCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  code: Int
  token: Int
  defaultLanguageCode: Int
  currencyCode: Int
  pricesIncludeTax: Int
}

input ChannelDeleteFilter {
  and: [ChannelDeleteFilter!]
  or: [ChannelDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  code: StringFieldComparison
  token: StringFieldComparison
  defaultLanguageCode: LanguageCodeFilterComparison
  currencyCode: CurrencyCodeFilterComparison
  pricesIncludeTax: BooleanFieldComparison
}

type ChannelDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  currencyCode: CurrencyCode
  pricesIncludeTax: Boolean
}

input ChannelFilter {
  and: [ChannelFilter!]
  or: [ChannelFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  code: StringFieldComparison
  token: StringFieldComparison
  defaultLanguageCode: LanguageCodeFilterComparison
  currencyCode: CurrencyCodeFilterComparison
  pricesIncludeTax: BooleanFieldComparison
}

type ChannelMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  currencyCode: CurrencyCode
}

type ChannelMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  currencyCode: CurrencyCode
}

input ChannelSort {
  field: ChannelSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ChannelSortFields {
  id
  createdAt
  updatedAt
  code
  token
  defaultLanguageCode
  currencyCode
  pricesIncludeTax
}

input ChannelSubscriptionFilter {
  and: [ChannelSubscriptionFilter!]
  or: [ChannelSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  code: StringFieldComparison
  token: StringFieldComparison
  defaultLanguageCode: LanguageCodeFilterComparison
  currencyCode: CurrencyCodeFilterComparison
  pricesIncludeTax: BooleanFieldComparison
}

input ChannelUpdateFilter {
  and: [ChannelUpdateFilter!]
  or: [ChannelUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  code: StringFieldComparison
  token: StringFieldComparison
  defaultLanguageCode: LanguageCodeFilterComparison
  currencyCode: CurrencyCodeFilterComparison
  pricesIncludeTax: BooleanFieldComparison
}

type Collection {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  isRoot: Boolean!
  inMenu: Boolean!
  position: Float!
  isPrivate: Boolean!
  name: String!
  description: String!
  children(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CollectionFilter = {}

    """Specify to sort results."""
    sorting: [CollectionSort!] = []
  ): [Collection!]!
  products(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  agreements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: BillingAgreementFilter = {}

    """Specify to sort results."""
    sorting: [BillingAgreementSort!] = []
  ): [BillingAgreement!]!
  cartPrice: CartPriceRules
  asset: Asset
  seo: Seo
  parent: Collection
  childrenAggregate(
    """Filter to find records to aggregate on"""
    filter: CollectionAggregateFilter
  ): CollectionChildrenAggregateResponse!
  productsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): CollectionProductsAggregateResponse!
  agreementsAggregate(
    """Filter to find records to aggregate on"""
    filter: BillingAgreementAggregateFilter
  ): CollectionAgreementsAggregateResponse!
}

input CollectionAggregateFilter {
  and: [CollectionAggregateFilter!]
  or: [CollectionAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isRoot: BooleanFieldComparison
  inMenu: BooleanFieldComparison
  position: NumberFieldComparison
  isPrivate: BooleanFieldComparison
  name: StringFieldComparison
  description: StringFieldComparison
}

type CollectionAggregateResponse {
  count: CollectionCountAggregate
  sum: CollectionSumAggregate
  avg: CollectionAvgAggregate
  min: CollectionMinAggregate
  max: CollectionMaxAggregate
}

type CollectionAgreementsAggregateResponse {
  count: CollectionAgreementsCountAggregate
  sum: CollectionAgreementsSumAggregate
  avg: CollectionAgreementsAvgAggregate
  min: CollectionAgreementsMinAggregate
  max: CollectionAgreementsMaxAggregate
}

type CollectionAgreementsAvgAggregate {
  value: Float
}

type CollectionAgreementsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  value: Int
}

type CollectionAgreementsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  value: Float
}

type CollectionAgreementsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  value: Float
}

type CollectionAgreementsSumAggregate {
  value: Float
}

type CollectionAvgAggregate {
  position: Float
}

type CollectionChildrenAggregateResponse {
  count: CollectionChildrenCountAggregate
  sum: CollectionChildrenSumAggregate
  avg: CollectionChildrenAvgAggregate
  min: CollectionChildrenMinAggregate
  max: CollectionChildrenMaxAggregate
}

type CollectionChildrenAvgAggregate {
  position: Float
}

type CollectionChildrenCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  isRoot: Int
  inMenu: Int
  position: Int
  isPrivate: Int
  name: Int
  description: Int
}

type CollectionChildrenMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  position: Float
  name: String
  description: String
}

type CollectionChildrenMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  position: Float
  name: String
  description: String
}

type CollectionChildrenSumAggregate {
  position: Float
}

type CollectionCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  isRoot: Int
  inMenu: Int
  position: Int
  isPrivate: Int
  name: Int
  description: Int
}

input CollectionDeleteFilter {
  and: [CollectionDeleteFilter!]
  or: [CollectionDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isRoot: BooleanFieldComparison
  inMenu: BooleanFieldComparison
  position: NumberFieldComparison
  isPrivate: BooleanFieldComparison
  name: StringFieldComparison
  description: StringFieldComparison
}

type CollectionDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  isRoot: Boolean
  inMenu: Boolean
  position: Float
  isPrivate: Boolean
  name: String
  description: String
}

input CollectionFilter {
  and: [CollectionFilter!]
  or: [CollectionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isRoot: BooleanFieldComparison
  inMenu: BooleanFieldComparison
  position: NumberFieldComparison
  isPrivate: BooleanFieldComparison
  name: StringFieldComparison
  description: StringFieldComparison
}

type CollectionMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  position: Float
  name: String
  description: String
}

type CollectionMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  position: Float
  name: String
  description: String
}

type CollectionProductsAggregateResponse {
  count: CollectionProductsCountAggregate
  min: CollectionProductsMinAggregate
  max: CollectionProductsMaxAggregate
}

type CollectionProductsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type CollectionProductsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type CollectionProductsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

input CollectionSort {
  field: CollectionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CollectionSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  isRoot
  inMenu
  position
  isPrivate
  name
  description
}

input CollectionSubscriptionFilter {
  and: [CollectionSubscriptionFilter!]
  or: [CollectionSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isRoot: BooleanFieldComparison
  inMenu: BooleanFieldComparison
  position: NumberFieldComparison
  isPrivate: BooleanFieldComparison
  name: StringFieldComparison
  description: StringFieldComparison
}

type CollectionSumAggregate {
  position: Float
}

input CollectionUpdateFilter {
  and: [CollectionUpdateFilter!]
  or: [CollectionUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isRoot: BooleanFieldComparison
  inMenu: BooleanFieldComparison
  position: NumberFieldComparison
  isPrivate: BooleanFieldComparison
  name: StringFieldComparison
  description: StringFieldComparison
}

type Country {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  code: String!
  name: String!
  enabled: Boolean!
  stores(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StoreFilter = {}

    """Specify to sort results."""
    sorting: [StoreSort!] = []
  ): [Store!]!
  zones(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZoneFilter = {}

    """Specify to sort results."""
    sorting: [ZoneSort!] = []
  ): [Zone!]!
  storesAggregate(
    """Filter to find records to aggregate on"""
    filter: StoreAggregateFilter
  ): CountryStoresAggregateResponse!
  zonesAggregate(
    """Filter to find records to aggregate on"""
    filter: ZoneAggregateFilter
  ): CountryZonesAggregateResponse!
}

input CountryAggregateFilter {
  and: [CountryAggregateFilter!]
  or: [CountryAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  name: StringFieldComparison
  enabled: BooleanFieldComparison
}

type CountryAggregateResponse {
  count: CountryCountAggregate
  min: CountryMinAggregate
  max: CountryMaxAggregate
}

type CountryCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
  name: Int
  enabled: Int
}

input CountryDeleteFilter {
  and: [CountryDeleteFilter!]
  or: [CountryDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  name: StringFieldComparison
  enabled: BooleanFieldComparison
}

type CountryDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
  enabled: Boolean
}

input CountryFilter {
  and: [CountryFilter!]
  or: [CountryFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  name: StringFieldComparison
  enabled: BooleanFieldComparison
}

type CountryMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
}

type CountryMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
}

input CountrySort {
  field: CountrySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum CountrySortFields {
  id
  createdAt
  updatedAt
  deletedAt
  code
  name
  enabled
}

type CountryStoresAggregateResponse {
  count: CountryStoresCountAggregate
  min: CountryStoresMinAggregate
  max: CountryStoresMaxAggregate
}

type CountryStoresCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  storeName: Int
  phoneNumber: Int
  officialemail: Int
  zipcode: Int
  streetAddress1: Int
  streetAddress2: Int
  GSTIN: Int
  singleStore: Int
  rentalStore: Int
  channelMarkets: Int
  services: Int
  assetAPI: Int
  mainAPI: Int
}

type CountryStoresMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

type CountryStoresMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

input CountrySubscriptionFilter {
  and: [CountrySubscriptionFilter!]
  or: [CountrySubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  name: StringFieldComparison
  enabled: BooleanFieldComparison
}

input CountryUpdateFilter {
  and: [CountryUpdateFilter!]
  or: [CountryUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  name: StringFieldComparison
  enabled: BooleanFieldComparison
}

type CountryZonesAggregateResponse {
  count: CountryZonesCountAggregate
  min: CountryZonesMinAggregate
  max: CountryZonesMaxAggregate
}

type CountryZonesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
}

type CountryZonesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

type CountryZonesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input CreateAccountSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AccountSubscriptionFilter!
}

input CreateAddress {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  addressType: AddressType
}

input CreateAddressSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AddressSubscriptionFilter!
}

input CreateAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AssetSubscriptionFilter!
}

input CreateCancellation {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input CreateCancellationSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CancellationSubscriptionFilter!
}

input CreateCartPriceRules {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
}

input CreateCartPriceRulesSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CartPriceRulesSubscriptionFilter!
}

input CreateChannel {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  currencyCode: CurrencyCode
  pricesIncludeTax: Boolean
}

input CreateChannelSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ChannelSubscriptionFilter!
}

input CreateCollection {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  isRoot: Boolean
  inMenu: Boolean
  position: Float
  isPrivate: Boolean
  name: String
  description: String
}

input CreateCollectionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CollectionSubscriptionFilter!
}

input CreateCountry {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
  enabled: Boolean
}

input CreateCountrySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CountrySubscriptionFilter!
}

input CreateDeliverySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: DeliverySubscriptionFilter!
}

input CreateFacet {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  isPrivate: Boolean
  code: String
}

input CreateFacetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetSubscriptionFilter!
}

input CreateFacetValue {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

input CreateFacetValueSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetValueSubscriptionFilter!
}

input CreateHsn {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  value: Float
}

input CreateHsnSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: HsnSubscriptionFilter!
}

input CreateInvoiceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: InvoiceSubscriptionFilter!
}

input CreateManyAddressesInput {
  """Array of records to create"""
  addresses: [CreateAddress!]!
}

input CreateManyCancellationsInput {
  """Array of records to create"""
  cancellations: [CreateCancellation!]!
}

input CreateManyCartPriceRulesInput {
  """Array of records to create"""
  cartPriceRules: [CreateCartPriceRules!]!
}

input CreateManyChannelsInput {
  """Array of records to create"""
  channels: [CreateChannel!]!
}

input CreateManyCollectionsInput {
  """Array of records to create"""
  collections: [CreateCollection!]!
}

input CreateManyCountriesInput {
  """Array of records to create"""
  countries: [CreateCountry!]!
}

input CreateManyFacetsInput {
  """Array of records to create"""
  facets: [CreateFacet!]!
}

input CreateManyFacetValuesInput {
  """Array of records to create"""
  facetValues: [CreateFacetValue!]!
}

input CreateManyHsnsInput {
  """Array of records to create"""
  hsns: [CreateHsn!]!
}

input CreateManyMenusInput {
  """Array of records to create"""
  menus: [CreateMenu!]!
}

input CreateManyPagesInput {
  """Array of records to create"""
  pages: [CreatePage!]!
}

input CreateManyProductAssetsInput {
  """Array of records to create"""
  productAssets: [CreateProductAsset!]!
}

input CreateManyProductOptionGroupsInput {
  """Array of records to create"""
  productOptionGroups: [CreateProductOptionGroup!]!
}

input CreateManyProductOptionsInput {
  """Array of records to create"""
  productOptions: [CreateProductOption!]!
}

input CreateManyProductsInput {
  """Array of records to create"""
  products: [CreateProduct!]!
}

input CreateManyProductVariantPricesInput {
  """Array of records to create"""
  productVariantPrices: [CreateProductVariantPrice!]!
}

input CreateManyPromotionVariantPricesInput {
  """Array of records to create"""
  promotionVariantPrices: [CreatePromotionVariantPrice!]!
}

input CreateManySalesInput {
  """Array of records to create"""
  sales: [CreateSale!]!
}

input CreateManySeosInput {
  """Array of records to create"""
  seos: [CreateSeo!]!
}

input CreateManyServiceablesInput {
  """Array of records to create"""
  serviceables: [CreateServiceable!]!
}

input CreateManyStockMovementsInput {
  """Array of records to create"""
  stockMovements: [CreateStockMovement!]!
}

input CreateManyStoresInput {
  """Array of records to create"""
  stores: [CreateStore!]!
}

input CreateManyTaxCategoriesInput {
  """Array of records to create"""
  taxCategories: [CreateTaxCategory!]!
}

input CreateManyTaxRatesInput {
  """Array of records to create"""
  taxRates: [CreateTaxRate!]!
}

input CreateManyViewCodesInput {
  """Array of records to create"""
  viewCodes: [CreateViewCode!]!
}

input CreateManyZipsInput {
  """Array of records to create"""
  zips: [CreateZip!]!
}

input CreateManyZonesInput {
  """Array of records to create"""
  zones: [CreateZone!]!
}

input CreateMenu {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

input CreateMenuSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MenuSubscriptionFilter!
}

input CreateOneAddressInput {
  """The record to create"""
  address: CreateAddress!
}

input CreateOneCancellationInput {
  """The record to create"""
  cancellation: CreateCancellation!
}

input CreateOneCartPriceRulesInput {
  """The record to create"""
  cartPriceRules: CreateCartPriceRules!
}

input CreateOneChannelInput {
  """The record to create"""
  channel: CreateChannel!
}

input CreateOneCollectionInput {
  """The record to create"""
  collection: CreateCollection!
}

input CreateOneCountryInput {
  """The record to create"""
  country: CreateCountry!
}

input CreateOneFacetInput {
  """The record to create"""
  facet: CreateFacet!
}

input CreateOneFacetValueInput {
  """The record to create"""
  facetValue: CreateFacetValue!
}

input CreateOneHsnInput {
  """The record to create"""
  hsn: CreateHsn!
}

input CreateOneMenuInput {
  """The record to create"""
  menu: CreateMenu!
}

input CreateOnePageInput {
  """The record to create"""
  page: CreatePage!
}

input CreateOneProductAssetInput {
  """The record to create"""
  productAsset: CreateProductAsset!
}

input CreateOneProductInput {
  """The record to create"""
  product: CreateProduct!
}

input CreateOneProductOptionGroupInput {
  """The record to create"""
  productOptionGroup: CreateProductOptionGroup!
}

input CreateOneProductOptionInput {
  """The record to create"""
  productOption: CreateProductOption!
}

input CreateOneProductVariantPriceInput {
  """The record to create"""
  productVariantPrice: CreateProductVariantPrice!
}

input CreateOnePromotionVariantPriceInput {
  """The record to create"""
  promotionVariantPrice: CreatePromotionVariantPrice!
}

input CreateOneSaleInput {
  """The record to create"""
  sale: CreateSale!
}

input CreateOneSeoInput {
  """The record to create"""
  seo: CreateSeo!
}

input CreateOneServiceableInput {
  """The record to create"""
  serviceable: CreateServiceable!
}

input CreateOneStockMovementInput {
  """The record to create"""
  stockMovement: CreateStockMovement!
}

input CreateOneStoreInput {
  """The record to create"""
  store: CreateStore!
}

input CreateOneTaxCategoryInput {
  """The record to create"""
  taxCategory: CreateTaxCategory!
}

input CreateOneTaxRateInput {
  """The record to create"""
  taxRate: CreateTaxRate!
}

input CreateOneViewCodeInput {
  """The record to create"""
  viewCode: CreateViewCode!
}

input CreateOneZipInput {
  """The record to create"""
  zip: CreateZip!
}

input CreateOneZoneInput {
  """The record to create"""
  zone: CreateZone!
}

input CreateOrderItemSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderItemSubscriptionFilter!
}

input CreateOrderLineSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderLineSubscriptionFilter!
}

input CreateOrderSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderSubscriptionFilter!
}

input CreatePage {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  title: String
  targetId: String
  single: JSON
  list: [String!]
  pageType: PageType
  pageCategory: PageCategory
}

input CreatePageSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PageSubscriptionFilter!
}

input CreatePaymentSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PaymentSubscriptionFilter!
}

input CreateProduct {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
  viewcode: [String!]
}

input CreateProductAsset {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input CreateProductAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductAssetSubscriptionFilter!
}

input CreateProductOption {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input CreateProductOptionGroup {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input CreateProductOptionGroupSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionGroupSubscriptionFilter!
}

input CreateProductOptionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionSubscriptionFilter!
}

input CreateProductSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductSubscriptionFilter!
}

input CreateProductVariantAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantAssetSubscriptionFilter!
}

input CreateProductVariantPrice {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
  taxIncluded: Boolean
}

input CreateProductVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantPriceSubscriptionFilter!
}

input CreateProductVariantSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantSubscriptionFilter!
}

input CreatePromotionVariantPrice {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
  forever: Boolean
  startsAt: DateTime
  endsAt: DateTime
  enabled: Boolean
}

input CreatePromotionVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PromotionVariantPriceSubscriptionFilter!
}

input CreateRefundSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RefundSubscriptionFilter!
}

input CreateRoleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RoleSubscriptionFilter!
}

input CreateSale {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input CreateSaleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SaleSubscriptionFilter!
}

input CreateSeo {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  urlKey: String
  metatitle: String
  metakeywords: [String!]
  metadesc: String
}

input CreateSeoSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SeoSubscriptionFilter!
}

input CreateServiceable {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  type: ServiceableTypes
  mode: ServiceableOrderTypes
}

input CreateServiceableSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ServiceableSubscriptionFilter!
}

input CreateSettlementsSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SettlementsSubscriptionFilter!
}

input CreateStockBackLogSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockBackLogSubscriptionFilter!
}

input CreateStockKeepingSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockKeepingSubscriptionFilter!
}

input CreateStockMovement {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input CreateStockMovementSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockMovementSubscriptionFilter!
}

input CreateStore {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  singleStore: Boolean
  rentalStore: Boolean
  channelMarkets: Boolean
  services: Boolean
  assetAPI: String
  mainAPI: String
  type: StoreTypeEnum
}

input CreateStoreSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StoreSubscriptionFilter!
}

input CreateTaxCategory {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input CreateTaxCategorySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxCategorySubscriptionFilter!
}

input CreateTaxRate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
  enabled: Boolean
}

input CreateTaxRateSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxRateSubscriptionFilter!
}

input CreateUserSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: UserSubscriptionFilter!
}

input CreateVendorLicenseSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorLicenseSubscriptionFilter!
}

input CreateVendorPlansSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorPlansSubscriptionFilter!
}

input CreateVendorSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorSubscriptionFilter!
}

input CreateViewCode {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  value: String
  description: String
}

input CreateViewCodeSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ViewCodeSubscriptionFilter!
}

input CreateZip {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

input CreateZipSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZipSubscriptionFilter!
}

input CreateZone {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input CreateZoneSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZoneSubscriptionFilter!
}

enum CurrencyCode {
  AED
  AFN
  ALL
  AMD
  ANG
  AOA
  ARS
  AUD
  AWG
  AZN
  BAM
  BBD
  BDT
  BGN
  BHD
  BIF
  BMD
  BND
  BOB
  BRL
  BSD
  BTN
  BWP
  BYN
  BZD
  CAD
  CDF
  CHF
  CLP
  CNY
  COP
  CRC
  CUC
  CUP
  CVE
  CZK
  DJF
  DKK
  DOP
  DZD
  EGP
  ERN
  ETB
  EUR
  FJD
  FKP
  GBP
  GEL
  GHS
  GIP
  GMD
  GNF
  GTQ
  GYD
  HKD
  HNL
  HRK
  HTG
  HUF
  IDR
  ILS
  INR
  IQD
  IRR
  ISK
  JMD
  JOD
  JPY
  KES
  KGS
  KHR
  KMF
  KPW
  KRW
  KWD
  KYD
  KZT
  LAK
  LBP
  LKR
  LRD
  LSL
  LYD
  MAD
  MDL
  MGA
  MKD
  MMK
  MNT
  MOP
  MRU
  MUR
  MVR
  MWK
  MXN
  MYR
  MZN
  NAD
  NGN
  NIO
  NOK
  NPR
  NZD
  OMR
  PAB
  PEN
  PGK
  PHP
  PKR
  PLN
  PYG
  QAR
  RON
  RSD
  RUB
  RWF
  SAR
  SBD
  SCR
  SDG
  SEK
  SGD
  SHP
  SLL
  SOS
  SRD
  SSP
  STN
  SVC
  SYP
  SZL
  THB
  TJS
  TMT
  TND
  TOP
  TRY
  TTD
  TWD
  TZS
  UAH
  UGX
  USD
  UYU
  UZS
  VES
  VND
  VUV
  WST
  XAF
  XCD
  XOF
  XPF
  YER
  ZAR
  ZMW
  ZWL
}

input CurrencyCodeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: CurrencyCode
  neq: CurrencyCode
  gt: CurrencyCode
  gte: CurrencyCode
  lt: CurrencyCode
  lte: CurrencyCode
  like: CurrencyCode
  notLike: CurrencyCode
  iLike: CurrencyCode
  notILike: CurrencyCode
  in: [CurrencyCode!]
  notIn: [CurrencyCode!]
}

type DataSource {
  sum: Float!
  amount: Float!
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteManyAddressesInput {
  """Filter to find records to delete"""
  filter: AddressDeleteFilter!
}

input DeleteManyAssetsInput {
  """Filter to find records to delete"""
  filter: AssetDeleteFilter!
}

input DeleteManyCancellationsInput {
  """Filter to find records to delete"""
  filter: CancellationDeleteFilter!
}

input DeleteManyCartPriceRulesInput {
  """Filter to find records to delete"""
  filter: CartPriceRulesDeleteFilter!
}

input DeleteManyChannelsInput {
  """Filter to find records to delete"""
  filter: ChannelDeleteFilter!
}

input DeleteManyCollectionsInput {
  """Filter to find records to delete"""
  filter: CollectionDeleteFilter!
}

input DeleteManyCountriesInput {
  """Filter to find records to delete"""
  filter: CountryDeleteFilter!
}

input DeleteManyFacetsInput {
  """Filter to find records to delete"""
  filter: FacetDeleteFilter!
}

input DeleteManyFacetValuesInput {
  """Filter to find records to delete"""
  filter: FacetValueDeleteFilter!
}

input DeleteManyHsnsInput {
  """Filter to find records to delete"""
  filter: HsnDeleteFilter!
}

input DeleteManyMenusInput {
  """Filter to find records to delete"""
  filter: MenuDeleteFilter!
}

input DeleteManyPagesInput {
  """Filter to find records to delete"""
  filter: PageDeleteFilter!
}

input DeleteManyProductAssetsInput {
  """Filter to find records to delete"""
  filter: ProductAssetDeleteFilter!
}

input DeleteManyProductOptionGroupsInput {
  """Filter to find records to delete"""
  filter: ProductOptionGroupDeleteFilter!
}

input DeleteManyProductOptionsInput {
  """Filter to find records to delete"""
  filter: ProductOptionDeleteFilter!
}

input DeleteManyProductsInput {
  """Filter to find records to delete"""
  filter: ProductDeleteFilter!
}

input DeleteManyProductVariantPricesInput {
  """Filter to find records to delete"""
  filter: ProductVariantPriceDeleteFilter!
}

input DeleteManyProductVariantsInput {
  """Filter to find records to delete"""
  filter: ProductVariantDeleteFilter!
}

input DeleteManyPromotionVariantPricesInput {
  """Filter to find records to delete"""
  filter: PromotionVariantPriceDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteManySalesInput {
  """Filter to find records to delete"""
  filter: SaleDeleteFilter!
}

input DeleteManySeosInput {
  """Filter to find records to delete"""
  filter: SeoDeleteFilter!
}

input DeleteManyServiceablesInput {
  """Filter to find records to delete"""
  filter: ServiceableDeleteFilter!
}

input DeleteManyStockBackLogsInput {
  """Filter to find records to delete"""
  filter: StockBackLogDeleteFilter!
}

input DeleteManyStockKeepingsInput {
  """Filter to find records to delete"""
  filter: StockKeepingDeleteFilter!
}

input DeleteManyStockMovementsInput {
  """Filter to find records to delete"""
  filter: StockMovementDeleteFilter!
}

input DeleteManyStoresInput {
  """Filter to find records to delete"""
  filter: StoreDeleteFilter!
}

input DeleteManyTaxCategoriesInput {
  """Filter to find records to delete"""
  filter: TaxCategoryDeleteFilter!
}

input DeleteManyTaxRatesInput {
  """Filter to find records to delete"""
  filter: TaxRateDeleteFilter!
}

input DeleteManyUsersInput {
  """Filter to find records to delete"""
  filter: UserDeleteFilter!
}

input DeleteManyZipsInput {
  """Filter to find records to delete"""
  filter: ZipDeleteFilter!
}

input DeleteManyZonesInput {
  """Filter to find records to delete"""
  filter: ZoneDeleteFilter!
}

input DeleteOneAccountSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AccountSubscriptionFilter!
}

input DeleteOneAddressSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AddressSubscriptionFilter!
}

input DeleteOneAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AssetSubscriptionFilter!
}

input DeleteOneCancellationSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CancellationSubscriptionFilter!
}

input DeleteOneCartPriceRulesSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CartPriceRulesSubscriptionFilter!
}

input DeleteOneChannelSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ChannelSubscriptionFilter!
}

input DeleteOneCollectionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CollectionSubscriptionFilter!
}

input DeleteOneCountrySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CountrySubscriptionFilter!
}

input DeleteOneDeliverySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: DeliverySubscriptionFilter!
}

input DeleteOneFacetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetSubscriptionFilter!
}

input DeleteOneFacetValueSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetValueSubscriptionFilter!
}

input DeleteOneHsnSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: HsnSubscriptionFilter!
}

input DeleteOneInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInvoiceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: InvoiceSubscriptionFilter!
}

input DeleteOneMenuSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MenuSubscriptionFilter!
}

input DeleteOneOrderItemSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderItemSubscriptionFilter!
}

input DeleteOneOrderLineSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderLineSubscriptionFilter!
}

input DeleteOneOrderSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderSubscriptionFilter!
}

input DeleteOnePageSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PageSubscriptionFilter!
}

input DeleteOnePaymentSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PaymentSubscriptionFilter!
}

input DeleteOneProductAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductAssetSubscriptionFilter!
}

input DeleteOneProductOptionGroupSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionGroupSubscriptionFilter!
}

input DeleteOneProductOptionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionSubscriptionFilter!
}

input DeleteOneProductSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductSubscriptionFilter!
}

input DeleteOneProductVariantAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantAssetSubscriptionFilter!
}

input DeleteOneProductVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantPriceSubscriptionFilter!
}

input DeleteOneProductVariantSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantSubscriptionFilter!
}

input DeleteOnePromotionVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PromotionVariantPriceSubscriptionFilter!
}

input DeleteOneRefundSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RefundSubscriptionFilter!
}

input DeleteOneRoleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RoleSubscriptionFilter!
}

input DeleteOneSaleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SaleSubscriptionFilter!
}

input DeleteOneSeoSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SeoSubscriptionFilter!
}

input DeleteOneServiceableSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ServiceableSubscriptionFilter!
}

input DeleteOneSettlementsSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SettlementsSubscriptionFilter!
}

input DeleteOneStockBackLogSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockBackLogSubscriptionFilter!
}

input DeleteOneStockKeepingSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockKeepingSubscriptionFilter!
}

input DeleteOneStockMovementSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockMovementSubscriptionFilter!
}

input DeleteOneStoreSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StoreSubscriptionFilter!
}

input DeleteOneTaxCategorySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxCategorySubscriptionFilter!
}

input DeleteOneTaxRateSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxRateSubscriptionFilter!
}

input DeleteOneUserSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: UserSubscriptionFilter!
}

input DeleteOneVendorLicenseSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorLicenseSubscriptionFilter!
}

input DeleteOneVendorPlansSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorPlansSubscriptionFilter!
}

input DeleteOneVendorSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorSubscriptionFilter!
}

input DeleteOneViewCodeSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ViewCodeSubscriptionFilter!
}

input DeleteOneZipSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZipSubscriptionFilter!
}

input DeleteOneZoneSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZoneSubscriptionFilter!
}

type Delivery {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  user: User
  signIn: [DeliverySignIn!]!
  signIns(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: DeliverySignInFilter = {}

    """Specify to sort results."""
    sorting: [DeliverySignInSort!] = []
  ): [DeliverySignIn!]
  signInsAggregate(
    """Filter to find records to aggregate on"""
    filter: DeliverySignInAggregateFilter
  ): DeliverySignInsAggregateResponse!
}

input DeliveryAggregateFilter {
  and: [DeliveryAggregateFilter!]
  or: [DeliveryAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type DeliveryAggregateResponse {
  count: DeliveryCountAggregate
  min: DeliveryMinAggregate
  max: DeliveryMaxAggregate
}

type DeliveryCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type DeliveryDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  user: User
  signIn: [DeliverySignIn!]
}

input DeliveryFilter {
  and: [DeliveryFilter!]
  or: [DeliveryFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  signIn: DeliveryFilterDeliverySignInFilter
}

input DeliveryFilterDeliverySignInFilter {
  and: [DeliveryFilterDeliverySignInFilter!]
  or: [DeliveryFilterDeliverySignInFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type DeliveryMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type DeliveryMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type DeliveryPool {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  signIn: DeliverySignIn!
  lines: [OrderLine!]!
}

type DeliverySignIn {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  delivery: Delivery!
  pool: DeliveryPool!
}

input DeliverySignInAggregateFilter {
  and: [DeliverySignInAggregateFilter!]
  or: [DeliverySignInAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

input DeliverySignInFilter {
  and: [DeliverySignInFilter!]
  or: [DeliverySignInFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type DeliverySignInsAggregateResponse {
  count: DeliverySignInsCountAggregate
  min: DeliverySignInsMinAggregate
  max: DeliverySignInsMaxAggregate
}

type DeliverySignInsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type DeliverySignInsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type DeliverySignInsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input DeliverySignInSort {
  field: DeliverySignInSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DeliverySignInSortFields {
  id
  createdAt
  updatedAt
  deletedAt
}

input DeliverySort {
  field: DeliverySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum DeliverySortFields {
  id
  createdAt
  updatedAt
  deletedAt
}

type DeliveryStrandedCount {
  count: Float!
}

input DeliverySubscriptionFilter {
  and: [DeliverySubscriptionFilter!]
  or: [DeliverySubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type Facet {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  name: String!
  isPrivate: Boolean!
  code: String!
  products(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  values(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: FacetValueFilter = {}

    """Specify to sort results."""
    sorting: [FacetValueSort!] = []
  ): [FacetValue!]!
  productsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): FacetProductsAggregateResponse!
  valuesAggregate(
    """Filter to find records to aggregate on"""
    filter: FacetValueAggregateFilter
  ): FacetValuesAggregateResponse!
}

input FacetAggregateFilter {
  and: [FacetAggregateFilter!]
  or: [FacetAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  isPrivate: BooleanFieldComparison
  code: StringFieldComparison
}

type FacetAggregateResponse {
  count: FacetCountAggregate
  min: FacetMinAggregate
  max: FacetMaxAggregate
}

type FacetCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  isPrivate: Int
  code: Int
}

input FacetDeleteFilter {
  and: [FacetDeleteFilter!]
  or: [FacetDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  isPrivate: BooleanFieldComparison
  code: StringFieldComparison
}

type FacetDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  isPrivate: Boolean
  code: String
}

input FacetFilter {
  and: [FacetFilter!]
  or: [FacetFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  isPrivate: BooleanFieldComparison
  code: StringFieldComparison
}

type FacetMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type FacetMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type FacetProductsAggregateResponse {
  count: FacetProductsCountAggregate
  min: FacetProductsMinAggregate
  max: FacetProductsMaxAggregate
}

type FacetProductsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type FacetProductsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type FacetProductsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

input FacetSort {
  field: FacetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FacetSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  name
  isPrivate
  code
}

input FacetSubscriptionFilter {
  and: [FacetSubscriptionFilter!]
  or: [FacetSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  isPrivate: BooleanFieldComparison
  code: StringFieldComparison
}

input FacetUpdateFilter {
  and: [FacetUpdateFilter!]
  or: [FacetUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  isPrivate: BooleanFieldComparison
  code: StringFieldComparison
}

type FacetValue {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  code: String!
  products(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  facet: Facet!
  productsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): FacetValueProductsAggregateResponse!
}

input FacetValueAggregateFilter {
  and: [FacetValueAggregateFilter!]
  or: [FacetValueAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
}

type FacetValueAggregateResponse {
  count: FacetValueCountAggregate
  min: FacetValueMinAggregate
  max: FacetValueMaxAggregate
}

type FacetValueCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
}

input FacetValueDeleteFilter {
  and: [FacetValueDeleteFilter!]
  or: [FacetValueDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
}

type FacetValueDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

input FacetValueFilter {
  and: [FacetValueFilter!]
  or: [FacetValueFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
}

type FacetValueMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

type FacetValueMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

type FacetValueProductsAggregateResponse {
  count: FacetValueProductsCountAggregate
  min: FacetValueProductsMinAggregate
  max: FacetValueProductsMaxAggregate
}

type FacetValueProductsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type FacetValueProductsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type FacetValueProductsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type FacetValuesAggregateResponse {
  count: FacetValuesCountAggregate
  min: FacetValuesMinAggregate
  max: FacetValuesMaxAggregate
}

type FacetValuesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
}

type FacetValuesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

type FacetValuesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

input FacetValueSort {
  field: FacetValueSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum FacetValueSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  code
}

input FacetValueSubscriptionFilter {
  and: [FacetValueSubscriptionFilter!]
  or: [FacetValueSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
}

input FacetValueUpdateFilter {
  and: [FacetValueUpdateFilter!]
  or: [FacetValueUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
}

type Hsn {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  code: String!
  value: Float!
  prices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantPriceSort!] = []
  ): [ProductVariantPrice!]!
  prods(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  pricesAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantPriceAggregateFilter
  ): HsnPricesAggregateResponse!
  prodsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): HsnProdsAggregateResponse!
}

input HsnAggregateFilter {
  and: [HsnAggregateFilter!]
  or: [HsnAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  value: NumberFieldComparison
}

type HsnAggregateResponse {
  count: HsnCountAggregate
  sum: HsnSumAggregate
  avg: HsnAvgAggregate
  min: HsnMinAggregate
  max: HsnMaxAggregate
}

type HsnAvgAggregate {
  value: Float
}

type HsnCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
  value: Int
}

input HsnDeleteFilter {
  and: [HsnDeleteFilter!]
  or: [HsnDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  value: NumberFieldComparison
}

type HsnDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  value: Float
}

input HsnFilter {
  and: [HsnFilter!]
  or: [HsnFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  value: NumberFieldComparison
  price: HsnFilterProductVariantPriceFilter
  prod: HsnFilterProductFilter
}

input HsnFilterProductFilter {
  and: [HsnFilterProductFilter!]
  or: [HsnFilterProductFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

input HsnFilterProductVariantPriceFilter {
  and: [HsnFilterProductVariantPriceFilter!]
  or: [HsnFilterProductVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type HsnMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  value: Float
}

type HsnMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  value: Float
}

type HsnPricesAggregateResponse {
  count: HsnPricesCountAggregate
  sum: HsnPricesSumAggregate
  avg: HsnPricesAvgAggregate
  min: HsnPricesMinAggregate
  max: HsnPricesMaxAggregate
}

type HsnPricesAvgAggregate {
  price: Float
}

type HsnPricesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  price: Int
  taxIncluded: Int
}

type HsnPricesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type HsnPricesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type HsnPricesSumAggregate {
  price: Float
}

type HsnProdsAggregateResponse {
  count: HsnProdsCountAggregate
  min: HsnProdsMinAggregate
  max: HsnProdsMaxAggregate
}

type HsnProdsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type HsnProdsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type HsnProdsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

input HsnSort {
  field: HsnSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum HsnSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  code
  value
}

input HsnSubscriptionFilter {
  and: [HsnSubscriptionFilter!]
  or: [HsnSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  value: NumberFieldComparison
}

type HsnSumAggregate {
  value: Float
}

input HsnUpdateFilter {
  and: [HsnUpdateFilter!]
  or: [HsnUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  value: NumberFieldComparison
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

type Invoice {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  type: InvoiceEnum!
  total: Float!
  amount: Float!
  fees: Float!
  tax: Float!
  nulled: Boolean!
  store: Store!
  line: OrderLine!
}

input InvoiceAggregateFilter {
  and: [InvoiceAggregateFilter!]
  or: [InvoiceAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  type: InvoiceEnumFilterComparison
  total: NumberFieldComparison
  amount: NumberFieldComparison
  fees: NumberFieldComparison
  tax: NumberFieldComparison
  nulled: BooleanFieldComparison
}

type InvoiceAggregateResponse {
  count: InvoiceCountAggregate
  sum: InvoiceSumAggregate
  avg: InvoiceAvgAggregate
  min: InvoiceMinAggregate
  max: InvoiceMaxAggregate
}

type InvoiceAvgAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type InvoiceCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  type: Int
  total: Int
  amount: Int
  fees: Int
  tax: Int
  nulled: Int
}

type InvoiceDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
  nulled: Boolean
}

enum InvoiceEnum {
  STORE
  CONSUMER
  MASTER
}

input InvoiceEnumFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: InvoiceEnum
  neq: InvoiceEnum
  gt: InvoiceEnum
  gte: InvoiceEnum
  lt: InvoiceEnum
  lte: InvoiceEnum
  like: InvoiceEnum
  notLike: InvoiceEnum
  iLike: InvoiceEnum
  notILike: InvoiceEnum
  in: [InvoiceEnum!]
  notIn: [InvoiceEnum!]
}

input InvoiceFilter {
  and: [InvoiceFilter!]
  or: [InvoiceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  type: InvoiceEnumFilterComparison
  total: NumberFieldComparison
  amount: NumberFieldComparison
  fees: NumberFieldComparison
  tax: NumberFieldComparison
  nulled: BooleanFieldComparison
  store: InvoiceFilterStoreFilter
  line: InvoiceFilterOrderLineFilter
}

input InvoiceFilterOrderLineFilter {
  and: [InvoiceFilterOrderLineFilter!]
  or: [InvoiceFilterOrderLineFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

input InvoiceFilterStoreFilter {
  and: [InvoiceFilterStoreFilter!]
  or: [InvoiceFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type InvoiceMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type InvoiceMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

input InvoiceSort {
  field: InvoiceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum InvoiceSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  type
  total
  amount
  fees
  tax
  nulled
}

input InvoiceSubscriptionFilter {
  and: [InvoiceSubscriptionFilter!]
  or: [InvoiceSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  type: InvoiceEnumFilterComparison
  total: NumberFieldComparison
  amount: NumberFieldComparison
  fees: NumberFieldComparison
  tax: NumberFieldComparison
  nulled: BooleanFieldComparison
}

type InvoiceSumAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

enum LanguageCode {
  aa
  ab
  af
  ak
  sq
  am
  ar
  an
  hy
  as
  av
  ae
  ay
  az
  ba
  bm
  eu
  be
  bn
  bh
  bi
  bs
  br
  bg
  my
  ca
  ch
  ce
  zh
  cu
  cv
  kw
  co
  cr
  cs
  da
  dv
  nl
  dz
  en
  eo
  et
  ee
  fo
  fj
  fi
  fr
  fy
  ff
  ka
  de
  gd
  ga
  gl
  gv
  el
  gn
  gu
  ht
  ha
  he
  hz
  hi
  ho
  hr
  hu
  ig
  is
  io
  ii
  iu
  ie
  ia
  id
  ik
  it
  jv
  ja
  kl
  kn
  ks
  kr
  kk
  km
  ki
  rw
  ky
  kv
  kg
  ko
  kj
  ku
  lo
  la
  lv
  li
  ln
  lt
  lb
  lu
  lg
  mk
  mh
  ml
  mi
  mr
  ms
  mg
  mt
  mn
  na
  nv
  nr
  nd
  ng
  ne
  nn
  nb
  no
  ny
  oc
  oj
  or
  om
  os
  pa
  fa
  pi
  pl
  pt
  ps
  qu
  rm
  ro
  rn
  ru
  sg
  sa
  si
  sk
  sl
  se
  sm
  sn
  sd
  so
  st
  es
  sc
  sr
  ss
  su
  sw
  sv
  ty
  ta
  tt
  te
  tg
  tl
  th
  bo
  ti
  to
  tn
  ts
  tk
  tr
  tw
  ug
  uk
  ur
  uz
  ve
  vi
  vo
  cy
  wa
  wo
  xh
  yi
  yo
  za
  zu
}

input LanguageCodeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: LanguageCode
  neq: LanguageCode
  gt: LanguageCode
  gte: LanguageCode
  lt: LanguageCode
  lte: LanguageCode
  like: LanguageCode
  notLike: LanguageCode
  iLike: LanguageCode
  notILike: LanguageCode
  in: [LanguageCode!]
  notIn: [LanguageCode!]
}

type Menu {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
  targetId: String!
  target: MenuBuilderTypes!
  children(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: MenuFilter = {}

    """Specify to sort results."""
    sorting: [MenuSort!] = []
  ): [Menu!]!
  asset: Asset
  parent: Menu
  childrenAggregate(
    """Filter to find records to aggregate on"""
    filter: MenuAggregateFilter
  ): MenuChildrenAggregateResponse!
}

input MenuAggregateFilter {
  and: [MenuAggregateFilter!]
  or: [MenuAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  target: MenuBuilderTypesFilterComparison
}

type MenuAggregateResponse {
  count: MenuCountAggregate
  min: MenuMinAggregate
  max: MenuMaxAggregate
}

enum MenuBuilderTypes {
  COLLECTION
  VARIANT
  FACET
  PROMO
  HEADER
}

input MenuBuilderTypesFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: MenuBuilderTypes
  neq: MenuBuilderTypes
  gt: MenuBuilderTypes
  gte: MenuBuilderTypes
  lt: MenuBuilderTypes
  lte: MenuBuilderTypes
  like: MenuBuilderTypes
  notLike: MenuBuilderTypes
  iLike: MenuBuilderTypes
  notILike: MenuBuilderTypes
  in: [MenuBuilderTypes!]
  notIn: [MenuBuilderTypes!]
}

type MenuChildrenAggregateResponse {
  count: MenuChildrenCountAggregate
  min: MenuChildrenMinAggregate
  max: MenuChildrenMaxAggregate
}

type MenuChildrenCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  title: Int
  targetId: Int
  target: Int
}

type MenuChildrenMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

type MenuChildrenMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

type MenuCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  title: Int
  targetId: Int
  target: Int
}

input MenuDeleteFilter {
  and: [MenuDeleteFilter!]
  or: [MenuDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  target: MenuBuilderTypesFilterComparison
}

type MenuDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

input MenuFilter {
  and: [MenuFilter!]
  or: [MenuFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  target: MenuBuilderTypesFilterComparison
}

type MenuMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

type MenuMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

type MenuResponseTypes {
  menu: String!
}

input MenuSort {
  field: MenuSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum MenuSortFields {
  id
  createdAt
  updatedAt
  title
  targetId
  target
}

input MenuSubscriptionFilter {
  and: [MenuSubscriptionFilter!]
  or: [MenuSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  target: MenuBuilderTypesFilterComparison
}

input MenuUpdateFilter {
  and: [MenuUpdateFilter!]
  or: [MenuUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  target: MenuBuilderTypesFilterComparison
}

type Mutation {
  administratorLogin(password: String!, email: String!): AdministratorDto!
  createAdministrator(type: AdministratorEnum!, password: String!, phone: String!, email: String!, lname: String!, fname: String!): Administrator!
  updateAdministratorPassword(newpassword: String!, password: String!, email: String!): User!
  deleteOneAsset(input: DeleteOneInput!): AssetDeleteResponse!
  deleteManyAssets(input: DeleteManyAssetsInput!): DeleteManyResponse!
  removeFeaturedsFromAsset(input: RelationsInput!): Asset!
  removeProductAssetsFromAsset(input: RelationsInput!): Asset!
  removeStoreFromAsset(input: RelationInput!): Asset!
  removeMenuFromAsset(input: RelationInput!): Asset!
  removeCollectionFromAsset(input: RelationInput!): Asset!
  addFeaturedsToAsset(input: RelationsInput!): Asset!
  addProductAssetsToAsset(input: RelationsInput!): Asset!
  setStoreOnAsset(input: RelationInput!): Asset!
  setMenuOnAsset(input: RelationInput!): Asset!
  setCollectionOnAsset(input: RelationInput!): Asset!
  createAsset(file: Upload!): Asset!
  createRole(roles: [Permission!]!, description: String!, code: String!): Role!
  updateRole(roles: [Permission!]!, description: String!, id: ID!): Role!
  deleteOneCollection(input: DeleteOneInput!): CollectionDeleteResponse!
  deleteManyCollections(input: DeleteManyCollectionsInput!): DeleteManyResponse!
  updateOneCollection(input: UpdateOneCollectionInput!): Collection!
  updateManyCollections(input: UpdateManyCollectionsInput!): UpdateManyResponse!
  createOneCollection(input: CreateOneCollectionInput!): Collection!
  createManyCollections(input: CreateManyCollectionsInput!): [Collection!]!
  removeChildrenFromCollection(input: RelationsInput!): Collection!
  removeProductsFromCollection(input: RelationsInput!): Collection!
  removeAgreementsFromCollection(input: RelationsInput!): Collection!
  removeCartPriceFromCollection(input: RelationInput!): Collection!
  removeAssetFromCollection(input: RelationInput!): Collection!
  removeSeoFromCollection(input: RelationInput!): Collection!
  removeParentFromCollection(input: RelationInput!): Collection!
  addChildrenToCollection(input: RelationsInput!): Collection!
  addProductsToCollection(input: RelationsInput!): Collection!
  addAgreementsToCollection(input: RelationsInput!): Collection!
  setCartPriceOnCollection(input: RelationInput!): Collection!
  setAssetOnCollection(input: RelationInput!): Collection!
  setSeoOnCollection(input: RelationInput!): Collection!
  setParentOnCollection(input: RelationInput!): Collection!
  AddParentToChildCollection(childId: String!, parentId: String!): Collection!
  deleteOneChannel(input: DeleteOneInput!): ChannelDeleteResponse!
  deleteManyChannels(input: DeleteManyChannelsInput!): DeleteManyResponse!
  updateOneChannel(input: UpdateOneChannelInput!): Channel!
  updateManyChannels(input: UpdateManyChannelsInput!): UpdateManyResponse!
  createOneChannel(input: CreateOneChannelInput!): Channel!
  createManyChannels(input: CreateManyChannelsInput!): [Channel!]!
  deleteOneStore(input: DeleteOneInput!): StoreDeleteResponse!
  deleteManyStores(input: DeleteManyStoresInput!): DeleteManyResponse!
  updateOneStore(input: UpdateOneStoreInput!): Store!
  updateManyStores(input: UpdateManyStoresInput!): UpdateManyResponse!
  createOneStore(input: CreateOneStoreInput!): Store!
  createManyStores(input: CreateManyStoresInput!): [Store!]!
  removeInvoicesFromStore(input: RelationsInput!): Store!
  removeZipsFromStore(input: RelationsInput!): Store!
  removeBacklogsFromStore(input: RelationsInput!): Store!
  removeCartsFromStore(input: RelationsInput!): Store!
  removePricesFromStore(input: RelationsInput!): Store!
  removeSettlementsFromStore(input: RelationsInput!): Store!
  removeSkusFromStore(input: RelationsInput!): Store!
  removeLogoFromStore(input: RelationInput!): Store!
  removeBalanceFromStore(input: RelationInput!): Store!
  removeCountryFromStore(input: RelationInput!): Store!
  addInvoicesToStore(input: RelationsInput!): Store!
  addZipsToStore(input: RelationsInput!): Store!
  addBacklogsToStore(input: RelationsInput!): Store!
  addCartsToStore(input: RelationsInput!): Store!
  addPricesToStore(input: RelationsInput!): Store!
  addSettlementsToStore(input: RelationsInput!): Store!
  addSkusToStore(input: RelationsInput!): Store!
  setLogoOnStore(input: RelationInput!): Store!
  setBalanceOnStore(input: RelationInput!): Store!
  setCountryOnStore(input: RelationInput!): Store!
  CreateDefaultStore(countryId: String!, zipcode: String!, streetAddress2: String!, streetAddress1: String!, GSTIN: String!, officialemail: String!, phoneNumber: String!, storeName: String!): Store!
  deleteOneTaxCategory(input: DeleteOneInput!): TaxCategoryDeleteResponse!
  deleteManyTaxCategories(input: DeleteManyTaxCategoriesInput!): DeleteManyResponse!
  updateOneTaxCategory(input: UpdateOneTaxCategoryInput!): TaxCategory!
  updateManyTaxCategories(input: UpdateManyTaxCategoriesInput!): UpdateManyResponse!
  createOneTaxCategory(input: CreateOneTaxCategoryInput!): TaxCategory!
  createManyTaxCategories(input: CreateManyTaxCategoriesInput!): [TaxCategory!]!
  removeRatesFromTaxCategory(input: RelationsInput!): TaxCategory!
  addRatesToTaxCategory(input: RelationsInput!): TaxCategory!
  deleteOneTaxRate(input: DeleteOneInput!): TaxRateDeleteResponse!
  deleteManyTaxRates(input: DeleteManyTaxRatesInput!): DeleteManyResponse!
  updateOneTaxRate(input: UpdateOneTaxRateInput!): TaxRate!
  updateManyTaxRates(input: UpdateManyTaxRatesInput!): UpdateManyResponse!
  createOneTaxRate(input: CreateOneTaxRateInput!): TaxRate!
  createManyTaxRates(input: CreateManyTaxRatesInput!): [TaxRate!]!
  removeVariantsFromTaxRate(input: RelationsInput!): TaxRate!
  removeZoneFromTaxRate(input: RelationInput!): TaxRate!
  removeCategoryFromTaxRate(input: RelationInput!): TaxRate!
  addVariantsToTaxRate(input: RelationsInput!): TaxRate!
  setZoneOnTaxRate(input: RelationInput!): TaxRate!
  setCategoryOnTaxRate(input: RelationInput!): TaxRate!
  deleteOneUser(input: DeleteOneInput!): UserDeleteResponse!
  deleteManyUsers(input: DeleteManyUsersInput!): DeleteManyResponse!
  removeOrdersFromUser(input: RelationsInput!): User!
  removeAddressesFromUser(input: RelationsInput!): User!
  removeDeliveryFromUser(input: RelationInput!): User!
  removeVendorFromUser(input: RelationInput!): User!
  removeAdministratorFromUser(input: RelationInput!): User!
  addOrdersToUser(input: RelationsInput!): User!
  addAddressesToUser(input: RelationsInput!): User!
  setDeliveryOnUser(input: RelationInput!): User!
  setVendorOnUser(input: RelationInput!): User!
  setAdministratorOnUser(input: RelationInput!): User!
  RequestResetCode(email: String!): ResetCode!
  removeZipsFromVendor(input: RelationsInput!): Vendor!
  removeServiceableFromVendor(input: RelationInput!): Vendor!
  removeAccountFromVendor(input: RelationInput!): Vendor!
  removeStoreFromVendor(input: RelationInput!): Vendor!
  removeLicenseFromVendor(input: RelationInput!): Vendor!
  removeUserFromVendor(input: RelationInput!): Vendor!
  addZipsToVendor(input: RelationsInput!): Vendor!
  setServiceableOnVendor(input: RelationInput!): Vendor!
  setAccountOnVendor(input: RelationInput!): Vendor!
  setStoreOnVendor(input: RelationInput!): Vendor!
  setLicenseOnVendor(input: RelationInput!): Vendor!
  setUserOnVendor(input: RelationInput!): Vendor!
  LoginVendor(password: String!, email: String!): VendorDto!
  RegisterVendor(rentals: Boolean!, streetAddress2: String!, streetAddress1: String!, zipcode: String!, region: ID!, officialEmail: String!, storeNumber: String!, storeName: String!, password: String!, phone: String!, lastname: String!, firstname: String!, planID: String!, email: String!): VendorDto!
  deleteOneZone(input: DeleteOneInput!): ZoneDeleteResponse!
  deleteManyZones(input: DeleteManyZonesInput!): DeleteManyResponse!
  updateOneZone(input: UpdateOneZoneInput!): Zone!
  updateManyZones(input: UpdateManyZonesInput!): UpdateManyResponse!
  createOneZone(input: CreateOneZoneInput!): Zone!
  createManyZones(input: CreateManyZonesInput!): [Zone!]!
  removeMembersFromZone(input: RelationsInput!): Zone!
  removeStoresFromZone(input: RelationsInput!): Zone!
  removeTaxratesFromZone(input: RelationsInput!): Zone!
  addMembersToZone(input: RelationsInput!): Zone!
  addStoresToZone(input: RelationsInput!): Zone!
  addTaxratesToZone(input: RelationsInput!): Zone!
  AddCountryToZone(countryId: ID!, id: ID!): Zone!
  deleteOneCountry(input: DeleteOneInput!): CountryDeleteResponse!
  deleteManyCountries(input: DeleteManyCountriesInput!): DeleteManyResponse!
  updateOneCountry(input: UpdateOneCountryInput!): Country!
  updateManyCountries(input: UpdateManyCountriesInput!): UpdateManyResponse!
  createOneCountry(input: CreateOneCountryInput!): Country!
  createManyCountries(input: CreateManyCountriesInput!): [Country!]!
  removeStoresFromCountry(input: RelationsInput!): Country!
  removeZonesFromCountry(input: RelationsInput!): Country!
  addStoresToCountry(input: RelationsInput!): Country!
  addZonesToCountry(input: RelationsInput!): Country!
  deleteOneSeo(input: DeleteOneInput!): SeoDeleteResponse!
  deleteManySeos(input: DeleteManySeosInput!): DeleteManyResponse!
  updateOneSeo(input: UpdateOneSeoInput!): Seo!
  updateManySeos(input: UpdateManySeosInput!): UpdateManyResponse!
  createOneSeo(input: CreateOneSeoInput!): Seo!
  createManySeos(input: CreateManySeosInput!): [Seo!]!
  removeVariantFromSeo(input: RelationInput!): Seo!
  removeCollectionFromSeo(input: RelationInput!): Seo!
  setVariantOnSeo(input: RelationInput!): Seo!
  setCollectionOnSeo(input: RelationInput!): Seo!
  createProductSeo(metadesc: String!, metakeywords: [String!]!, metatitle: String!, urlKey: String!, variantId: ID!): Seo!
  updateProductSeo(metadesc: String!, metakeywords: [String!]!, metatitle: String!, urlKey: String!, seoId: ID!): Seo!
  deleteOneFacet(input: DeleteOneInput!): FacetDeleteResponse!
  deleteManyFacets(input: DeleteManyFacetsInput!): DeleteManyResponse!
  updateOneFacet(input: UpdateOneFacetInput!): Facet!
  updateManyFacets(input: UpdateManyFacetsInput!): UpdateManyResponse!
  createOneFacet(input: CreateOneFacetInput!): Facet!
  createManyFacets(input: CreateManyFacetsInput!): [Facet!]!
  removeProductsFromFacet(input: RelationsInput!): Facet!
  removeValuesFromFacet(input: RelationsInput!): Facet!
  addProductsToFacet(input: RelationsInput!): Facet!
  addValuesToFacet(input: RelationsInput!): Facet!
  deleteOneFacetValue(input: DeleteOneInput!): FacetValueDeleteResponse!
  deleteManyFacetValues(input: DeleteManyFacetValuesInput!): DeleteManyResponse!
  updateOneFacetValue(input: UpdateOneFacetValueInput!): FacetValue!
  updateManyFacetValues(input: UpdateManyFacetValuesInput!): UpdateManyResponse!
  createOneFacetValue(input: CreateOneFacetValueInput!): FacetValue!
  createManyFacetValues(input: CreateManyFacetValuesInput!): [FacetValue!]!
  removeProductsFromFacetValue(input: RelationsInput!): FacetValue!
  removeFacetFromFacetValue(input: RelationInput!): FacetValue!
  addProductsToFacetValue(input: RelationsInput!): FacetValue!
  setFacetOnFacetValue(input: RelationInput!): FacetValue!
  deleteOneProduct(input: DeleteOneInput!): ProductDeleteResponse!
  deleteManyProducts(input: DeleteManyProductsInput!): DeleteManyResponse!
  updateOneProduct(input: UpdateOneProductInput!): Product!
  updateManyProducts(input: UpdateManyProductsInput!): UpdateManyResponse!
  createOneProduct(input: CreateOneProductInput!): Product!
  createManyProducts(input: CreateManyProductsInput!): [Product!]!
  removeOptionsFromProduct(input: RelationsInput!): Product!
  removeFacetsFromProduct(input: RelationsInput!): Product!
  removeVariantsFromProduct(input: RelationsInput!): Product!
  removeAssetsFromProduct(input: RelationsInput!): Product!
  removeHsnFromProduct(input: RelationInput!): Product!
  removeCollectionFromProduct(input: RelationInput!): Product!
  removeFeaturedAssetFromProduct(input: RelationInput!): Product!
  removeServiceableFromProduct(input: RelationInput!): Product!
  addOptionsToProduct(input: RelationsInput!): Product!
  addFacetsToProduct(input: RelationsInput!): Product!
  addVariantsToProduct(input: RelationsInput!): Product!
  addAssetsToProduct(input: RelationsInput!): Product!
  setHsnOnProduct(input: RelationInput!): Product!
  setCollectionOnProduct(input: RelationInput!): Product!
  setFeaturedAssetOnProduct(input: RelationInput!): Product!
  setServiceableOnProduct(input: RelationInput!): Product!
  CreateProduct(facet: [String!]!, asset: [String!]!, featured: String!, slug: String!, desc: String!, name: String!): Product!
  UpdateProductCollection(collectionId: ID!, id: ID!): Product!
  updateProduct(viewcode: [String!]!, facet: [String!]!, asset: [String!]!, featured: String!, id: ID!, desc: String!, name: String!): Product!
  deleteOneProductVariant(input: DeleteOneInput!): ProductVariantDeleteResponse!
  deleteManyProductVariants(input: DeleteManyProductVariantsInput!): DeleteManyResponse!
  removeLinesFromProductVariant(input: RelationsInput!): ProductVariant!
  removeStocksFromProductVariant(input: RelationsInput!): ProductVariant!
  removeAgreementsFromProductVariant(input: RelationsInput!): ProductVariant!
  removePricesFromProductVariant(input: RelationsInput!): ProductVariant!
  removeSeoFromProductVariant(input: RelationInput!): ProductVariant!
  removeSpecsFromProductVariant(input: RelationInput!): ProductVariant!
  removeAssetFromProductVariant(input: RelationInput!): ProductVariant!
  removeProductFromProductVariant(input: RelationInput!): ProductVariant!
  addLinesToProductVariant(input: RelationsInput!): ProductVariant!
  addStocksToProductVariant(input: RelationsInput!): ProductVariant!
  addAgreementsToProductVariant(input: RelationsInput!): ProductVariant!
  addPricesToProductVariant(input: RelationsInput!): ProductVariant!
  setSeoOnProductVariant(input: RelationInput!): ProductVariant!
  setSpecsOnProductVariant(input: RelationInput!): ProductVariant!
  setAssetOnProductVariant(input: RelationInput!): ProductVariant!
  setProductOnProductVariant(input: RelationInput!): ProductVariant!
  CreateProductVariants(options: String!, prodId: ID!): [ProductVariant!]!
  CreateProductVariantSpecification(specs: JSON!, variantId: ID!): ProductVariantSpecs!
  UpdateProductVariantSpecification(specs: JSON!, id: ID!): ProductVariantSpecs!
  UpdateVariantViewCode(viewcode: [String!]!, variantId: ID!): ProductVariant!
  deleteOneProductOption(input: DeleteOneInput!): ProductOptionDeleteResponse!
  deleteManyProductOptions(input: DeleteManyProductOptionsInput!): DeleteManyResponse!
  updateOneProductOption(input: UpdateOneProductOptionInput!): ProductOption!
  updateManyProductOptions(input: UpdateManyProductOptionsInput!): UpdateManyResponse!
  createOneProductOption(input: CreateOneProductOptionInput!): ProductOption!
  createManyProductOptions(input: CreateManyProductOptionsInput!): [ProductOption!]!
  removeVariantsFromProductOption(input: RelationsInput!): ProductOption!
  removeGroupFromProductOption(input: RelationInput!): ProductOption!
  addVariantsToProductOption(input: RelationsInput!): ProductOption!
  setGroupOnProductOption(input: RelationInput!): ProductOption!
  deleteOneProductOptionGroup(input: DeleteOneInput!): ProductOptionGroupDeleteResponse!
  deleteManyProductOptionGroups(input: DeleteManyProductOptionGroupsInput!): DeleteManyResponse!
  updateOneProductOptionGroup(input: UpdateOneProductOptionGroupInput!): ProductOptionGroup!
  updateManyProductOptionGroups(input: UpdateManyProductOptionGroupsInput!): UpdateManyResponse!
  createOneProductOptionGroup(input: CreateOneProductOptionGroupInput!): ProductOptionGroup!
  createManyProductOptionGroups(input: CreateManyProductOptionGroupsInput!): [ProductOptionGroup!]!
  removeOptionsFromProductOptionGroup(input: RelationsInput!): ProductOptionGroup!
  removeProductFromProductOptionGroup(input: RelationInput!): ProductOptionGroup!
  addOptionsToProductOptionGroup(input: RelationsInput!): ProductOptionGroup!
  setProductOnProductOptionGroup(input: RelationInput!): ProductOptionGroup!
  deleteOneProductVariantPrice(input: DeleteOneInput!): ProductVariantPriceDeleteResponse!
  deleteManyProductVariantPrices(input: DeleteManyProductVariantPricesInput!): DeleteManyResponse!
  updateOneProductVariantPrice(input: UpdateOneProductVariantPriceInput!): ProductVariantPrice!
  updateManyProductVariantPrices(input: UpdateManyProductVariantPricesInput!): UpdateManyResponse!
  createOneProductVariantPrice(input: CreateOneProductVariantPriceInput!): ProductVariantPrice!
  createManyProductVariantPrices(input: CreateManyProductVariantPricesInput!): [ProductVariantPrice!]!
  removeBacklogsFromProductVariantPrice(input: RelationsInput!): ProductVariantPrice!
  removePromopriceFromProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  removeStoreFromProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  removeTaxFromProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  removeVariantFromProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  addBacklogsToProductVariantPrice(input: RelationsInput!): ProductVariantPrice!
  setPromopriceOnProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  setStoreOnProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  setTaxOnProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  setVariantOnProductVariantPrice(input: RelationInput!): ProductVariantPrice!
  CreateVariantPrice(storeId: ID, taxIncluded: Boolean!, taxId: ID!, price: Float!, variantId: ID!): ProductVariantPrice!
  UpdateVariantPrice(taxIncluded: Boolean!, taxId: ID!, price: Float!, variantPriceId: ID!): ProductVariantPrice!
  removeAssetFromProductVariantAsset(input: RelationInput!): ProductVariantAsset!
  removeVariantFromProductVariantAsset(input: RelationInput!): ProductVariantAsset!
  setAssetOnProductVariantAsset(input: RelationInput!): ProductVariantAsset!
  setVariantOnProductVariantAsset(input: RelationInput!): ProductVariantAsset!
  CreateProductVariantAsset(assetId: ID!, id: ID!): ProductVariantAsset!
  deleteOneProductAsset(input: DeleteOneInput!): ProductAssetDeleteResponse!
  deleteManyProductAssets(input: DeleteManyProductAssetsInput!): DeleteManyResponse!
  updateOneProductAsset(input: UpdateOneProductAssetInput!): ProductAsset!
  updateManyProductAssets(input: UpdateManyProductAssetsInput!): UpdateManyResponse!
  createOneProductAsset(input: CreateOneProductAssetInput!): ProductAsset!
  createManyProductAssets(input: CreateManyProductAssetsInput!): [ProductAsset!]!
  removeAssetFromProductAsset(input: RelationInput!): ProductAsset!
  removeProductFromProductAsset(input: RelationInput!): ProductAsset!
  setAssetOnProductAsset(input: RelationInput!): ProductAsset!
  setProductOnProductAsset(input: RelationInput!): ProductAsset!
  removeLicencesFromVendorPlans(input: RelationsInput!): VendorPlans!
  addLicencesToVendorPlans(input: RelationsInput!): VendorPlans!
  CreatePlan(tenureStrategy: VendorPlanTenure!, priceStrategy: VendorPlanPrice!, value: Float!, name: String!): VendorPlans!
  UpdatePlan(status: Boolean!, id: ID!): VendorPlans!
  removePlansFromVendorLicense(input: RelationInput!): VendorLicense!
  removeVendorFromVendorLicense(input: RelationInput!): VendorLicense!
  setPlansOnVendorLicense(input: RelationInput!): VendorLicense!
  setVendorOnVendorLicense(input: RelationInput!): VendorLicense!
  CreateVendorProdVariant(value: Float!, storeId: ID!, variantId: ID!): BillingAgreement!
  UpdateVendorProdVariant(value: Float!, id: ID!): BillingAgreement!
  CreateBillingRequest(value: String!, id: String!): BillingAgreementRequest!
  UpdateBillingRequest(value: String!, id: String!): BillingAgreementRequest!
  deleteOneStockKeeping(input: DeleteOneInput!): StockKeepingDeleteResponse!
  deleteManyStockKeepings(input: DeleteManyStockKeepingsInput!): DeleteManyResponse!
  updateOneStockKeeping(input: UpdateOneStockKeepingInput!): StockKeeping!
  updateManyStockKeepings(input: UpdateManyStockKeepingsInput!): UpdateManyResponse!
  removeSalesFromStockKeeping(input: RelationsInput!): StockKeeping!
  removeCancelsFromStockKeeping(input: RelationsInput!): StockKeeping!
  removeMovementsFromStockKeeping(input: RelationsInput!): StockKeeping!
  removeStoreFromStockKeeping(input: RelationInput!): StockKeeping!
  removeVariantFromStockKeeping(input: RelationInput!): StockKeeping!
  addSalesToStockKeeping(input: RelationsInput!): StockKeeping!
  addCancelsToStockKeeping(input: RelationsInput!): StockKeeping!
  addMovementsToStockKeeping(input: RelationsInput!): StockKeeping!
  setStoreOnStockKeeping(input: RelationInput!): StockKeeping!
  setVariantOnStockKeeping(input: RelationInput!): StockKeeping!
  createOrUpdateStock(type: StockKeepingType, stockId: ID, storeId: ID, variantId: ID, stockstatus: Boolean!, backorder: Boolean!, multiple: Boolean!, sku: String!, threshold: Float!, quantity: Float!): StockKeeping!
  deleteOneSale(input: DeleteOneInput!): SaleDeleteResponse!
  deleteManySales(input: DeleteManySalesInput!): DeleteManyResponse!
  updateOneSale(input: UpdateOneSaleInput!): Sale!
  updateManySales(input: UpdateManySalesInput!): UpdateManyResponse!
  createOneSale(input: CreateOneSaleInput!): Sale!
  createManySales(input: CreateManySalesInput!): [Sale!]!
  removeKeepingFromSale(input: RelationInput!): Sale!
  setKeepingOnSale(input: RelationInput!): Sale!
  deleteOneStockMovement(input: DeleteOneInput!): StockMovementDeleteResponse!
  deleteManyStockMovements(input: DeleteManyStockMovementsInput!): DeleteManyResponse!
  updateOneStockMovement(input: UpdateOneStockMovementInput!): StockMovement!
  updateManyStockMovements(input: UpdateManyStockMovementsInput!): UpdateManyResponse!
  createOneStockMovement(input: CreateOneStockMovementInput!): StockMovement!
  createManyStockMovements(input: CreateManyStockMovementsInput!): [StockMovement!]!
  removeKeepingFromStockMovement(input: RelationInput!): StockMovement!
  setKeepingOnStockMovement(input: RelationInput!): StockMovement!
  deleteOneCancellation(input: DeleteOneInput!): CancellationDeleteResponse!
  deleteManyCancellations(input: DeleteManyCancellationsInput!): DeleteManyResponse!
  updateOneCancellation(input: UpdateOneCancellationInput!): Cancellation!
  updateManyCancellations(input: UpdateManyCancellationsInput!): UpdateManyResponse!
  createOneCancellation(input: CreateOneCancellationInput!): Cancellation!
  createManyCancellations(input: CreateManyCancellationsInput!): [Cancellation!]!
  removeKeepingFromCancellation(input: RelationInput!): Cancellation!
  setKeepingOnCancellation(input: RelationInput!): Cancellation!
  removeLinesFromOrder(input: RelationsInput!): Order!
  removePaymentFromOrder(input: RelationInput!): Order!
  removeUserFromOrder(input: RelationInput!): Order!
  addLinesToOrder(input: RelationsInput!): Order!
  setPaymentOnOrder(input: RelationInput!): Order!
  setUserOnOrder(input: RelationInput!): Order!
  createOrderAdmin(orderLineDto: [OrderLineDto!]!, address: String!, userId: ID!): Order!
  deleteOneZip(input: DeleteOneInput!): ZipDeleteResponse!
  deleteManyZips(input: DeleteManyZipsInput!): DeleteManyResponse!
  updateOneZip(input: UpdateOneZipInput!): Zip!
  updateManyZips(input: UpdateManyZipsInput!): UpdateManyResponse!
  createOneZip(input: CreateOneZipInput!): Zip!
  createManyZips(input: CreateManyZipsInput!): [Zip!]!
  removeStoresFromZip(input: RelationsInput!): Zip!
  removeVendorsFromZip(input: RelationsInput!): Zip!
  addStoresToZip(input: RelationsInput!): Zip!
  addVendorsToZip(input: RelationsInput!): Zip!
  CreateZipToVendor(zips: [ID!]!, vendorId: ID!): Vendor!
  deleteOneMenu(input: DeleteOneInput!): MenuDeleteResponse!
  deleteManyMenus(input: DeleteManyMenusInput!): DeleteManyResponse!
  updateOneMenu(input: UpdateOneMenuInput!): Menu!
  updateManyMenus(input: UpdateManyMenusInput!): UpdateManyResponse!
  createOneMenu(input: CreateOneMenuInput!): Menu!
  createManyMenus(input: CreateManyMenusInput!): [Menu!]!
  removeChildrenFromMenu(input: RelationsInput!): Menu!
  removeAssetFromMenu(input: RelationInput!): Menu!
  removeParentFromMenu(input: RelationInput!): Menu!
  addChildrenToMenu(input: RelationsInput!): Menu!
  setAssetOnMenu(input: RelationInput!): Menu!
  setParentOnMenu(input: RelationInput!): Menu!
  CreateMenuChildNode(target: String!, targetId: String!, title: String!, nodeId: ID!): Menu!
  deleteOnePage(input: DeleteOneInput!): PageDeleteResponse!
  deleteManyPages(input: DeleteManyPagesInput!): DeleteManyResponse!
  updateOnePage(input: UpdateOnePageInput!): Page!
  updateManyPages(input: UpdateManyPagesInput!): UpdateManyResponse!
  createOnePage(input: CreateOnePageInput!): Page!
  createManyPages(input: CreateManyPagesInput!): [Page!]!
  deleteOneAddress(input: DeleteOneInput!): AddressDeleteResponse!
  deleteManyAddresses(input: DeleteManyAddressesInput!): DeleteManyResponse!
  updateOneAddress(input: UpdateOneAddressInput!): Address!
  updateManyAddresses(input: UpdateManyAddressesInput!): UpdateManyResponse!
  createOneAddress(input: CreateOneAddressInput!): Address!
  createManyAddresses(input: CreateManyAddressesInput!): [Address!]!
  removeUserFromAddress(input: RelationInput!): Address!
  setUserOnAddress(input: RelationInput!): Address!
  removeStoreFromSettlements(input: RelationInput!): Settlements!
  setStoreOnSettlements(input: RelationInput!): Settlements!
  CreateSettlement(storeId: ID!): Settlements!
  UpdateSettlement(transactionId: String, settlementId: ID!): Settlements!
  updateOneOrderLine(input: UpdateOneOrderLineInput!): OrderLine!
  updateManyOrderLines(input: UpdateManyOrderLinesInput!): UpdateManyResponse!
  removeInvoicesFromOrderLine(input: RelationsInput!): OrderLine!
  removeServiceableFromOrderLine(input: RelationInput!): OrderLine!
  removeRefundFromOrderLine(input: RelationInput!): OrderLine!
  removePoolFromOrderLine(input: RelationInput!): OrderLine!
  removeStoreFromOrderLine(input: RelationInput!): OrderLine!
  removeItemFromOrderLine(input: RelationInput!): OrderLine!
  removeOrderFromOrderLine(input: RelationInput!): OrderLine!
  addInvoicesToOrderLine(input: RelationsInput!): OrderLine!
  setServiceableOnOrderLine(input: RelationInput!): OrderLine!
  setRefundOnOrderLine(input: RelationInput!): OrderLine!
  setPoolOnOrderLine(input: RelationInput!): OrderLine!
  setStoreOnOrderLine(input: RelationInput!): OrderLine!
  setItemOnOrderLine(input: RelationInput!): OrderLine!
  setOrderOnOrderLine(input: RelationInput!): OrderLine!
  removeLineFromOrderItem(input: RelationInput!): OrderItem!
  removeTaxCategoryFromOrderItem(input: RelationInput!): OrderItem!
  removeProductVariantFromOrderItem(input: RelationInput!): OrderItem!
  setLineOnOrderItem(input: RelationInput!): OrderItem!
  setTaxCategoryOnOrderItem(input: RelationInput!): OrderItem!
  setProductVariantOnOrderItem(input: RelationInput!): OrderItem!
  deleteOnePromotionVariantPrice(input: DeleteOneInput!): PromotionVariantPriceDeleteResponse!
  deleteManyPromotionVariantPrices(input: DeleteManyPromotionVariantPricesInput!): DeleteManyResponse!
  updateOnePromotionVariantPrice(input: UpdateOnePromotionVariantPriceInput!): PromotionVariantPrice!
  updateManyPromotionVariantPrices(input: UpdateManyPromotionVariantPricesInput!): UpdateManyResponse!
  createOnePromotionVariantPrice(input: CreateOnePromotionVariantPriceInput!): PromotionVariantPrice!
  createManyPromotionVariantPrices(input: CreateManyPromotionVariantPricesInput!): [PromotionVariantPrice!]!
  removePriceFromPromotionVariantPrice(input: RelationInput!): PromotionVariantPrice!
  setPriceOnPromotionVariantPrice(input: RelationInput!): PromotionVariantPrice!
  deleteOneCartPriceRules(input: DeleteOneInput!): CartPriceRulesDeleteResponse!
  deleteManyCartPriceRules(input: DeleteManyCartPriceRulesInput!): DeleteManyResponse!
  updateOneCartPriceRules(input: UpdateOneCartPriceRulesInput!): CartPriceRules!
  updateManyCartPriceRules(input: UpdateManyCartPriceRulesInput!): UpdateManyResponse!
  createOneCartPriceRules(input: CreateOneCartPriceRulesInput!): CartPriceRules!
  createManyCartPriceRules(input: CreateManyCartPriceRulesInput!): [CartPriceRules!]!
  removeCollectionFromCartPriceRules(input: RelationInput!): CartPriceRules!
  setCollectionOnCartPriceRules(input: RelationInput!): CartPriceRules!
  removeVendorFromAccount(input: RelationInput!): Account!
  setVendorOnAccount(input: RelationInput!): Account!
  removeSignInsFromDelivery(input: RelationsInput!): Delivery!
  removeUserFromDelivery(input: RelationInput!): Delivery!
  addSignInsToDelivery(input: RelationsInput!): Delivery!
  setUserOnDelivery(input: RelationInput!): Delivery!
  SetNewDeliveryGuy(userId: ID!): Delivery!
  SetDeliverySignIn(type: Boolean!): DeliverySignIn!
  CreatePaymentMethod(secret: String!, api: String!): PaymentMethod!
  UpdatePaymentMethod(enabled: Boolean!, modeId: String!): PaymentMethod!
  deleteOneStockBackLog(input: DeleteOneInput!): StockBackLogDeleteResponse!
  deleteManyStockBackLogs(input: DeleteManyStockBackLogsInput!): DeleteManyResponse!
  updateOneStockBackLog(input: UpdateOneStockBackLogInput!): StockBackLog!
  updateManyStockBackLogs(input: UpdateManyStockBackLogsInput!): UpdateManyResponse!
  removeStoreFromStockBackLog(input: RelationInput!): StockBackLog!
  removeVariantFromStockBackLog(input: RelationInput!): StockBackLog!
  setStoreOnStockBackLog(input: RelationInput!): StockBackLog!
  setVariantOnStockBackLog(input: RelationInput!): StockBackLog!
  removeStoreFromInvoice(input: RelationInput!): Invoice!
  removeLineFromInvoice(input: RelationInput!): Invoice!
  setStoreOnInvoice(input: RelationInput!): Invoice!
  setLineOnInvoice(input: RelationInput!): Invoice!
  updateOneRefund(input: UpdateOneRefundInput!): Refund!
  updateManyRefunds(input: UpdateManyRefundsInput!): UpdateManyResponse!
  removeLineFromRefund(input: RelationInput!): Refund!
  setLineOnRefund(input: RelationInput!): Refund!
  removeOrderFromPayment(input: RelationInput!): Payment!
  setOrderOnPayment(input: RelationInput!): Payment!
  createOneViewCode(input: CreateOneViewCodeInput!): ViewCode!
  createManyViewCodes(input: CreateManyViewCodesInput!): [ViewCode!]!
  deleteOneHsn(input: DeleteOneInput!): HsnDeleteResponse!
  deleteManyHsns(input: DeleteManyHsnsInput!): DeleteManyResponse!
  updateOneHsn(input: UpdateOneHsnInput!): Hsn!
  updateManyHsns(input: UpdateManyHsnsInput!): UpdateManyResponse!
  createOneHsn(input: CreateOneHsnInput!): Hsn!
  createManyHsns(input: CreateManyHsnsInput!): [Hsn!]!
  removePricesFromHsn(input: RelationsInput!): Hsn!
  removeProdsFromHsn(input: RelationsInput!): Hsn!
  addPricesToHsn(input: RelationsInput!): Hsn!
  addProdsToHsn(input: RelationsInput!): Hsn!
  deleteOneServiceable(input: DeleteOneInput!): ServiceableDeleteResponse!
  deleteManyServiceables(input: DeleteManyServiceablesInput!): DeleteManyResponse!
  updateOneServiceable(input: UpdateOneServiceableInput!): Serviceable!
  updateManyServiceables(input: UpdateManyServiceablesInput!): UpdateManyResponse!
  createOneServiceable(input: CreateOneServiceableInput!): Serviceable!
  createManyServiceables(input: CreateManyServiceablesInput!): [Serviceable!]!
  removeProductsFromServiceable(input: RelationsInput!): Serviceable!
  removeVendorsFromServiceable(input: RelationsInput!): Serviceable!
  addProductsToServiceable(input: RelationsInput!): Serviceable!
  addVendorsToServiceable(input: RelationsInput!): Serviceable!
  AddServiceToVendor(vendor: ID!, service: ID!): Serviceable!
  AddServiceToProduct(product: ID!, service: ID!): Serviceable!
  removeServiceableToProduct(product: ID!): Product!
  removeServiceableToVendor(vendor: ID!): Vendor!
}

input NumberFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: Float
  neq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
  in: [Float!]
  notIn: [Float!]
  between: NumberFieldComparisonBetween
  notBetween: NumberFieldComparisonBetween
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

type Order {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  totalPrice: Float!
  address: String!
  lines(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderLineFilter = {}

    """Specify to sort results."""
    sorting: [OrderLineSort!] = []
  ): [OrderLine!]!
  payment: Payment
  user: User!
  linesAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderLineAggregateFilter
  ): OrderLinesAggregateResponse!
}

input OrderAggregateFilter {
  and: [OrderAggregateFilter!]
  or: [OrderAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  totalPrice: NumberFieldComparison
  address: StringFieldComparison
}

type OrderAggregateResponse {
  count: OrderCountAggregate
  sum: OrderSumAggregate
  avg: OrderAvgAggregate
  min: OrderMinAggregate
  max: OrderMaxAggregate
}

type OrderAvgAggregate {
  totalPrice: Float
}

type OrderCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  totalPrice: Int
  address: Int
}

type OrderDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  totalPrice: Float
  address: String
}

input OrderFilter {
  and: [OrderFilter!]
  or: [OrderFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  totalPrice: NumberFieldComparison
  address: StringFieldComparison
  line: OrderFilterOrderLineFilter
}

input OrderFilterOrderLineFilter {
  and: [OrderFilterOrderLineFilter!]
  or: [OrderFilterOrderLineFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

type OrderItem {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  quantity: Float!
  productVariant: ProductVariant!
  line: OrderLine!
  taxCategory: TaxRate!
}

input OrderItemAggregateFilter {
  and: [OrderItemAggregateFilter!]
  or: [OrderItemAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type OrderItemAggregateResponse {
  count: OrderItemCountAggregate
  sum: OrderItemSumAggregate
  avg: OrderItemAvgAggregate
  min: OrderItemMinAggregate
  max: OrderItemMaxAggregate
}

type OrderItemAvgAggregate {
  quantity: Float
}

type OrderItemCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  quantity: Int
}

type OrderItemDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  quantity: Float
  productVariant: ProductVariant
}

input OrderItemFilter {
  and: [OrderItemFilter!]
  or: [OrderItemFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type OrderItemMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  quantity: Float
}

type OrderItemMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  quantity: Float
}

input OrderItemSort {
  field: OrderItemSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderItemSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  quantity
}

input OrderItemSubscriptionFilter {
  and: [OrderItemSubscriptionFilter!]
  or: [OrderItemSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type OrderItemSumAggregate {
  quantity: Float
}

type OrderLine {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  priceField: JSON!
  stage: OrderStageType!
  invoices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): [Invoice!]!
  serviceable: ServiceableOrders!
  refund: Refund!
  pool: DeliveryPool!
  store: Store!
  item: OrderItem!
  order: Order!
  invoicesAggregate(
    """Filter to find records to aggregate on"""
    filter: InvoiceAggregateFilter
  ): OrderLineInvoicesAggregateResponse!
}

input OrderLineAggregateFilter {
  and: [OrderLineAggregateFilter!]
  or: [OrderLineAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

type OrderLineAggregateResponse {
  count: OrderLineCountAggregate
  min: OrderLineMinAggregate
  max: OrderLineMaxAggregate
}

type OrderLineCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  stage: Int
}

type OrderLineDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceField: JSON
  stage: OrderStageType
}

input OrderLineDto {
  priceId: String!
  quantity: Float!
}

input OrderLineFilter {
  and: [OrderLineFilter!]
  or: [OrderLineFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
  serviceable: OrderLineFilterServiceableOrdersFilter
  refund: OrderLineFilterRefundFilter
  pool: OrderLineFilterDeliveryPoolFilter
  store: OrderLineFilterStoreFilter
  invoice: OrderLineFilterInvoiceFilter
}

input OrderLineFilterDeliveryPoolFilter {
  and: [OrderLineFilterDeliveryPoolFilter!]
  or: [OrderLineFilterDeliveryPoolFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

input OrderLineFilterInvoiceFilter {
  and: [OrderLineFilterInvoiceFilter!]
  or: [OrderLineFilterInvoiceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  type: InvoiceEnumFilterComparison
  total: NumberFieldComparison
  amount: NumberFieldComparison
  fees: NumberFieldComparison
  tax: NumberFieldComparison
  nulled: BooleanFieldComparison
}

input OrderLineFilterRefundFilter {
  and: [OrderLineFilterRefundFilter!]
  or: [OrderLineFilterRefundFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  reason: StringFieldComparison
  destination: StringFieldComparison
  transactionId: StringFieldComparison
  stage: RefundEnumFilterComparison
}

input OrderLineFilterServiceableOrdersFilter {
  and: [OrderLineFilterServiceableOrdersFilter!]
  or: [OrderLineFilterServiceableOrdersFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  dateTime: DateFieldComparison
}

input OrderLineFilterStoreFilter {
  and: [OrderLineFilterStoreFilter!]
  or: [OrderLineFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type OrderLineInvoicesAggregateResponse {
  count: OrderLineInvoicesCountAggregate
  sum: OrderLineInvoicesSumAggregate
  avg: OrderLineInvoicesAvgAggregate
  min: OrderLineInvoicesMinAggregate
  max: OrderLineInvoicesMaxAggregate
}

type OrderLineInvoicesAvgAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type OrderLineInvoicesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  type: Int
  total: Int
  amount: Int
  fees: Int
  tax: Int
  nulled: Int
}

type OrderLineInvoicesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type OrderLineInvoicesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type OrderLineInvoicesSumAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type OrderLineMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  stage: OrderStageType
}

type OrderLineMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  stage: OrderStageType
}

type OrderLinesAggregateResponse {
  count: OrderLinesCountAggregate
  min: OrderLinesMinAggregate
  max: OrderLinesMaxAggregate
}

type OrderLinesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  stage: Int
}

type OrderLinesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  stage: OrderStageType
}

type OrderLinesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  stage: OrderStageType
}

input OrderLineSort {
  field: OrderLineSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderLineSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  stage
}

input OrderLineSubscriptionFilter {
  and: [OrderLineSubscriptionFilter!]
  or: [OrderLineSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

input OrderLineUpdateFilter {
  and: [OrderLineUpdateFilter!]
  or: [OrderLineUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

type OrderMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  totalPrice: Float
  address: String
}

type OrderMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  totalPrice: Float
  address: String
}

input OrderSort {
  field: OrderSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrderSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  totalPrice
  address
}

enum OrderStageType {
  CREATED
  PACKAGED
  PROCESSED
  SHIPPED
  DELIVERED
  RETURNINITIATED
  RETURNED
  RETURNEDREFUNDED
}

input OrderStageTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: OrderStageType
  neq: OrderStageType
  gt: OrderStageType
  gte: OrderStageType
  lt: OrderStageType
  lte: OrderStageType
  like: OrderStageType
  notLike: OrderStageType
  iLike: OrderStageType
  notILike: OrderStageType
  in: [OrderStageType!]
  notIn: [OrderStageType!]
}

input OrderSubscriptionFilter {
  and: [OrderSubscriptionFilter!]
  or: [OrderSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  totalPrice: NumberFieldComparison
  address: StringFieldComparison
}

type OrderSumAggregate {
  totalPrice: Float
}

type Page {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  title: String!
  targetId: String!
  single: JSON
  list: [String!]
  pageType: PageType!
  pageCategory: PageCategory!
}

input PageAggregateFilter {
  and: [PageAggregateFilter!]
  or: [PageAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  pageType: PageTypeFilterComparison
  pageCategory: PageCategoryFilterComparison
}

type PageAggregateResponse {
  count: PageCountAggregate
  min: PageMinAggregate
  max: PageMaxAggregate
}

enum PageCategory {
  HOME
  CATEGORY
  SINGLEPROD
  PRODVARIANT
}

input PageCategoryFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PageCategory
  neq: PageCategory
  gt: PageCategory
  gte: PageCategory
  lt: PageCategory
  lte: PageCategory
  like: PageCategory
  notLike: PageCategory
  iLike: PageCategory
  notILike: PageCategory
  in: [PageCategory!]
  notIn: [PageCategory!]
}

type PageCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  title: Int
  targetId: Int
  pageType: Int
  pageCategory: Int
}

input PageDeleteFilter {
  and: [PageDeleteFilter!]
  or: [PageDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  pageType: PageTypeFilterComparison
  pageCategory: PageCategoryFilterComparison
}

type PageDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  title: String
  targetId: String
  single: JSON
  list: [String!]
  pageType: PageType
  pageCategory: PageCategory
}

input PageFilter {
  and: [PageFilter!]
  or: [PageFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  pageType: PageTypeFilterComparison
  pageCategory: PageCategoryFilterComparison
}

type PageMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  title: String
  targetId: String
  pageType: PageType
  pageCategory: PageCategory
}

type PageMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  title: String
  targetId: String
  pageType: PageType
  pageCategory: PageCategory
}

input PageSort {
  field: PageSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PageSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  title
  targetId
  pageType
  pageCategory
}

input PageSubscriptionFilter {
  and: [PageSubscriptionFilter!]
  or: [PageSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  pageType: PageTypeFilterComparison
  pageCategory: PageCategoryFilterComparison
}

enum PageType {
  LIST
  SINGLE
}

input PageTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PageType
  neq: PageType
  gt: PageType
  gte: PageType
  lt: PageType
  lte: PageType
  like: PageType
  notLike: PageType
  iLike: PageType
  notILike: PageType
  in: [PageType!]
  notIn: [PageType!]
}

input PageUpdateFilter {
  and: [PageUpdateFilter!]
  or: [PageUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  title: StringFieldComparison
  targetId: StringFieldComparison
  pageType: PageTypeFilterComparison
  pageCategory: PageCategoryFilterComparison
}

type Payment {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  amount: Float!
  errorMessage: String
  transactionId: String
  order: Order!
}

input PaymentAggregateFilter {
  and: [PaymentAggregateFilter!]
  or: [PaymentAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  errorMessage: StringFieldComparison
  transactionId: StringFieldComparison
}

type PaymentAggregateResponse {
  count: PaymentCountAggregate
  sum: PaymentSumAggregate
  avg: PaymentAvgAggregate
  min: PaymentMinAggregate
  max: PaymentMaxAggregate
}

type PaymentAvgAggregate {
  amount: Float
}

type PaymentCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  amount: Int
  errorMessage: Int
  transactionId: Int
}

type PaymentDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  errorMessage: String
  transactionId: String
}

input PaymentFilter {
  and: [PaymentFilter!]
  or: [PaymentFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  errorMessage: StringFieldComparison
  transactionId: StringFieldComparison
}

type PaymentMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  errorMessage: String
  transactionId: String
}

type PaymentMethod {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  api: String!
  secretKey: String!
  enabled: Boolean!
}

type PaymentMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  errorMessage: String
  transactionId: String
}

input PaymentSort {
  field: PaymentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PaymentSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  amount
  errorMessage
  transactionId
}

input PaymentSubscriptionFilter {
  and: [PaymentSubscriptionFilter!]
  or: [PaymentSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  errorMessage: StringFieldComparison
  transactionId: StringFieldComparison
}

type PaymentSumAggregate {
  amount: Float
}

enum Permission {
  CreateOrder
  ReadOrder
  UpdateOrder
  DeleteOrder
  CreateInvoices
  ReadInvoices
  UpdateInvoices
  DeleteInvoices
  CreateCatalog
  ReadCatalog
  UpdateCatalog
  DeleteCatalog
  CreateCustomer
  ReadCustomer
  UpdateCustomer
  DeleteCustomer
  CreateAdministrator
  ReadAdministrator
  UpdateAdministrator
  DeleteAdministrator
  CreatePromotion
  ReadPromotion
  UpdatePromotion
  DeletePromotion
  CreateSettings
  ReadSettings
  UpdateSettings
  DeleteSettings
  CreateCommunications
  ReadCommunications
  UpdateCommunications
  DeleteCommunications
  CreateSeo
  ReadSeo
  UpdateSeo
  DeleteSeo
}

enum PricePromoType {
  FLAT
  PERCENTAGE
}

input PricePromoTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: PricePromoType
  neq: PricePromoType
  gt: PricePromoType
  gte: PricePromoType
  lt: PricePromoType
  lte: PricePromoType
  like: PricePromoType
  notLike: PricePromoType
  iLike: PricePromoType
  notILike: PricePromoType
  in: [PricePromoType!]
  notIn: [PricePromoType!]
}

type ProdDataSource {
  sum: Float!
}

type Product {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  productName: String!
  slug: String!
  description: String!
  viewcode: [String!]!
  options(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductOptionGroupFilter = {}

    """Specify to sort results."""
    sorting: [ProductOptionGroupSort!] = []
  ): [ProductOptionGroup!]!
  facets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: FacetValueFilter = {}

    """Specify to sort results."""
    sorting: [FacetValueSort!] = []
  ): [FacetValue!]!
  variants(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantSort!] = []
  ): [ProductVariant!]!
  assets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductAssetFilter = {}

    """Specify to sort results."""
    sorting: [ProductAssetSort!] = []
  ): [ProductAsset!]!
  hsn: Hsn
  collection: Collection
  featuredAsset: Asset!
  serviceable: Serviceable
  optionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductOptionGroupAggregateFilter
  ): ProductOptionsAggregateResponse!
  facetsAggregate(
    """Filter to find records to aggregate on"""
    filter: FacetValueAggregateFilter
  ): ProductFacetsAggregateResponse!
  variantsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantAggregateFilter
  ): ProductVariantsAggregateResponse!
  assetsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAssetAggregateFilter
  ): ProductAssetsAggregateResponse!
}

input ProductAggregateFilter {
  and: [ProductAggregateFilter!]
  or: [ProductAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

type ProductAggregateResponse {
  count: ProductCountAggregate
  min: ProductMinAggregate
  max: ProductMaxAggregate
}

type ProductAsset {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  asset: Asset!
  product: Product!
}

input ProductAssetAggregateFilter {
  and: [ProductAssetAggregateFilter!]
  or: [ProductAssetAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductAssetAggregateResponse {
  count: ProductAssetCountAggregate
  min: ProductAssetMinAggregate
  max: ProductAssetMaxAggregate
}

type ProductAssetCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

input ProductAssetDeleteFilter {
  and: [ProductAssetDeleteFilter!]
  or: [ProductAssetDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductAssetDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input ProductAssetFilter {
  and: [ProductAssetFilter!]
  or: [ProductAssetFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductAssetMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type ProductAssetMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type ProductAssetsAggregateResponse {
  count: ProductAssetsCountAggregate
  min: ProductAssetsMinAggregate
  max: ProductAssetsMaxAggregate
}

type ProductAssetsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type ProductAssetsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type ProductAssetsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input ProductAssetSort {
  field: ProductAssetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductAssetSortFields {
  id
  createdAt
  updatedAt
  deletedAt
}

input ProductAssetSubscriptionFilter {
  and: [ProductAssetSubscriptionFilter!]
  or: [ProductAssetSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

input ProductAssetUpdateFilter {
  and: [ProductAssetUpdateFilter!]
  or: [ProductAssetUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

input ProductDeleteFilter {
  and: [ProductDeleteFilter!]
  or: [ProductDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

type ProductDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
  viewcode: [String!]
}

type ProductFacetsAggregateResponse {
  count: ProductFacetsCountAggregate
  min: ProductFacetsMinAggregate
  max: ProductFacetsMaxAggregate
}

type ProductFacetsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
}

type ProductFacetsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

type ProductFacetsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

input ProductFilter {
  and: [ProductFilter!]
  or: [ProductFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

type ProductMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type ProductMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type ProductOption {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  name: String!
  code: String!
  variants(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantSort!] = []
  ): [ProductVariant!]!
  group: ProductOptionGroup!
  variantsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantAggregateFilter
  ): ProductOptionVariantsAggregateResponse!
}

input ProductOptionAggregateFilter {
  and: [ProductOptionAggregateFilter!]
  or: [ProductOptionAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionAggregateResponse {
  count: ProductOptionCountAggregate
  min: ProductOptionMinAggregate
  max: ProductOptionMaxAggregate
}

type ProductOptionCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  code: Int
}

input ProductOptionDeleteFilter {
  and: [ProductOptionDeleteFilter!]
  or: [ProductOptionDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input ProductOptionFilter {
  and: [ProductOptionFilter!]
  or: [ProductOptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionGroup {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  name: String!
  code: String!
  options(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductOptionFilter = {}

    """Specify to sort results."""
    sorting: [ProductOptionSort!] = []
  ): [ProductOption!]!
  product: Product!
  optionsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductOptionAggregateFilter
  ): ProductOptionGroupOptionsAggregateResponse!
}

input ProductOptionGroupAggregateFilter {
  and: [ProductOptionGroupAggregateFilter!]
  or: [ProductOptionGroupAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionGroupAggregateResponse {
  count: ProductOptionGroupCountAggregate
  min: ProductOptionGroupMinAggregate
  max: ProductOptionGroupMaxAggregate
}

type ProductOptionGroupCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  code: Int
}

input ProductOptionGroupDeleteFilter {
  and: [ProductOptionGroupDeleteFilter!]
  or: [ProductOptionGroupDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionGroupDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input ProductOptionGroupFilter {
  and: [ProductOptionGroupFilter!]
  or: [ProductOptionGroupFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionGroupMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionGroupMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionGroupOptionsAggregateResponse {
  count: ProductOptionGroupOptionsCountAggregate
  min: ProductOptionGroupOptionsMinAggregate
  max: ProductOptionGroupOptionsMaxAggregate
}

type ProductOptionGroupOptionsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  code: Int
}

type ProductOptionGroupOptionsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionGroupOptionsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input ProductOptionGroupSort {
  field: ProductOptionGroupSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductOptionGroupSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  name
  code
}

input ProductOptionGroupSubscriptionFilter {
  and: [ProductOptionGroupSubscriptionFilter!]
  or: [ProductOptionGroupSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

input ProductOptionGroupUpdateFilter {
  and: [ProductOptionGroupUpdateFilter!]
  or: [ProductOptionGroupUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionsAggregateResponse {
  count: ProductOptionsCountAggregate
  min: ProductOptionsMinAggregate
  max: ProductOptionsMaxAggregate
}

type ProductOptionsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  code: Int
}

type ProductOptionsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

type ProductOptionsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input ProductOptionSort {
  field: ProductOptionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductOptionSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  name
  code
}

input ProductOptionSubscriptionFilter {
  and: [ProductOptionSubscriptionFilter!]
  or: [ProductOptionSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

input ProductOptionUpdateFilter {
  and: [ProductOptionUpdateFilter!]
  or: [ProductOptionUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  code: StringFieldComparison
}

type ProductOptionVariantsAggregateResponse {
  count: ProductOptionVariantsCountAggregate
  sum: ProductOptionVariantsSumAggregate
  avg: ProductOptionVariantsAvgAggregate
  min: ProductOptionVariantsMinAggregate
  max: ProductOptionVariantsMaxAggregate
}

type ProductOptionVariantsAvgAggregate {
  dum_price: Float
  rating: Float
}

type ProductOptionVariantsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  dum_price: Int
  enabled: Int
  sku: Int
  name: Int
  rating: Int
  trackInventory: Int
}

type ProductOptionVariantsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

type ProductOptionVariantsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

type ProductOptionVariantsSumAggregate {
  dum_price: Float
  rating: Float
}

input ProductSort {
  field: ProductSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  productName
  slug
  description
}

input ProductSubscriptionFilter {
  and: [ProductSubscriptionFilter!]
  or: [ProductSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

input ProductUpdateFilter {
  and: [ProductUpdateFilter!]
  or: [ProductUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

type ProductVariant {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  dum_price: Float!
  enabled: Boolean!
  sku: String!
  name: String!
  rating: Float!
  product: Product!
  trackInventory: Boolean!
  specs: ProductVariantSpecs
  viewcode: [String!]!
  lines(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderItemFilter = {}

    """Specify to sort results."""
    sorting: [OrderItemSort!] = []
  ): [OrderItem!]!
  stocks(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockKeepingFilter = {}

    """Specify to sort results."""
    sorting: [StockKeepingSort!] = []
  ): [StockKeeping!]!
  agreements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: BillingAgreementFilter = {}

    """Specify to sort results."""
    sorting: [BillingAgreementSort!] = []
  ): [BillingAgreement!]
  prices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantPriceSort!] = []
  ): [ProductVariantPrice!]
  seo: Seo
  asset: ProductVariantAsset
  linesAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderItemAggregateFilter
  ): ProductVariantLinesAggregateResponse!
  stocksAggregate(
    """Filter to find records to aggregate on"""
    filter: StockKeepingAggregateFilter
  ): ProductVariantStocksAggregateResponse!
  agreementsAggregate(
    """Filter to find records to aggregate on"""
    filter: BillingAgreementAggregateFilter
  ): ProductVariantAgreementsAggregateResponse!
  pricesAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantPriceAggregateFilter
  ): ProductVariantPricesAggregateResponse!
}

input ProductVariantAggregateFilter {
  and: [ProductVariantAggregateFilter!]
  or: [ProductVariantAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
}

type ProductVariantAggregateResponse {
  count: ProductVariantCountAggregate
  sum: ProductVariantSumAggregate
  avg: ProductVariantAvgAggregate
  min: ProductVariantMinAggregate
  max: ProductVariantMaxAggregate
}

type ProductVariantAgreementsAggregateResponse {
  count: ProductVariantAgreementsCountAggregate
  sum: ProductVariantAgreementsSumAggregate
  avg: ProductVariantAgreementsAvgAggregate
  min: ProductVariantAgreementsMinAggregate
  max: ProductVariantAgreementsMaxAggregate
}

type ProductVariantAgreementsAvgAggregate {
  value: Float
}

type ProductVariantAgreementsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  value: Int
}

type ProductVariantAgreementsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  value: Float
}

type ProductVariantAgreementsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  value: Float
}

type ProductVariantAgreementsSumAggregate {
  value: Float
}

type ProductVariantAsset {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  asset: Asset!
  variant: ProductVariant!
}

input ProductVariantAssetAggregateFilter {
  and: [ProductVariantAssetAggregateFilter!]
  or: [ProductVariantAssetAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductVariantAssetAggregateResponse {
  count: ProductVariantAssetCountAggregate
  min: ProductVariantAssetMinAggregate
  max: ProductVariantAssetMaxAggregate
}

type ProductVariantAssetCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
}

type ProductVariantAssetDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input ProductVariantAssetFilter {
  and: [ProductVariantAssetFilter!]
  or: [ProductVariantAssetFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductVariantAssetMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

type ProductVariantAssetMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input ProductVariantAssetSort {
  field: ProductVariantAssetSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductVariantAssetSortFields {
  id
  createdAt
  updatedAt
  deletedAt
}

input ProductVariantAssetSubscriptionFilter {
  and: [ProductVariantAssetSubscriptionFilter!]
  or: [ProductVariantAssetSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
}

type ProductVariantAvgAggregate {
  dum_price: Float
  rating: Float
}

type ProductVariantCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  dum_price: Int
  enabled: Int
  sku: Int
  name: Int
  rating: Int
  trackInventory: Int
}

input ProductVariantDeleteFilter {
  and: [ProductVariantDeleteFilter!]
  or: [ProductVariantDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
}

type ProductVariantDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  enabled: Boolean
  sku: String
  name: String
  rating: Float
  product: Product
  trackInventory: Boolean
  specs: ProductVariantSpecs
  viewcode: [String!]
}

input ProductVariantFilter {
  and: [ProductVariantFilter!]
  or: [ProductVariantFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
  line: ProductVariantFilterOrderItemFilter
  agreements: ProductVariantFilterBillingAgreementFilter
  price: ProductVariantFilterProductVariantPriceFilter
}

input ProductVariantFilterBillingAgreementFilter {
  and: [ProductVariantFilterBillingAgreementFilter!]
  or: [ProductVariantFilterBillingAgreementFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  value: NumberFieldComparison
}

input ProductVariantFilterOrderItemFilter {
  and: [ProductVariantFilterOrderItemFilter!]
  or: [ProductVariantFilterOrderItemFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

input ProductVariantFilterProductVariantPriceFilter {
  and: [ProductVariantFilterProductVariantPriceFilter!]
  or: [ProductVariantFilterProductVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type ProductVariantLinesAggregateResponse {
  count: ProductVariantLinesCountAggregate
  sum: ProductVariantLinesSumAggregate
  avg: ProductVariantLinesAvgAggregate
  min: ProductVariantLinesMinAggregate
  max: ProductVariantLinesMaxAggregate
}

type ProductVariantLinesAvgAggregate {
  quantity: Float
}

type ProductVariantLinesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  quantity: Int
}

type ProductVariantLinesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  quantity: Float
}

type ProductVariantLinesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  quantity: Float
}

type ProductVariantLinesSumAggregate {
  quantity: Float
}

type ProductVariantMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

type ProductVariantMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

type ProductVariantPrice {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  price: Float!
  taxIncluded: Boolean!
  backlogs(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockBackLogFilter = {}

    """Specify to sort results."""
    sorting: [StockBackLogSort!] = []
  ): [StockBackLog!]
  promoprice: PromotionVariantPrice
  store: Store!
  tax: TaxRate
  variant: ProductVariant!
  backlogsAggregate(
    """Filter to find records to aggregate on"""
    filter: StockBackLogAggregateFilter
  ): ProductVariantPriceBacklogsAggregateResponse!
}

input ProductVariantPriceAggregateFilter {
  and: [ProductVariantPriceAggregateFilter!]
  or: [ProductVariantPriceAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type ProductVariantPriceAggregateResponse {
  count: ProductVariantPriceCountAggregate
  sum: ProductVariantPriceSumAggregate
  avg: ProductVariantPriceAvgAggregate
  min: ProductVariantPriceMinAggregate
  max: ProductVariantPriceMaxAggregate
}

type ProductVariantPriceAvgAggregate {
  price: Float
}

type ProductVariantPriceBacklogsAggregateResponse {
  count: ProductVariantPriceBacklogsCountAggregate
  sum: ProductVariantPriceBacklogsSumAggregate
  avg: ProductVariantPriceBacklogsAvgAggregate
  min: ProductVariantPriceBacklogsMinAggregate
  max: ProductVariantPriceBacklogsMaxAggregate
}

type ProductVariantPriceBacklogsAvgAggregate {
  quantity: Float
}

type ProductVariantPriceBacklogsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

type ProductVariantPriceBacklogsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type ProductVariantPriceBacklogsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type ProductVariantPriceBacklogsSumAggregate {
  quantity: Float
}

type ProductVariantPriceCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  price: Int
  taxIncluded: Int
}

input ProductVariantPriceDeleteFilter {
  and: [ProductVariantPriceDeleteFilter!]
  or: [ProductVariantPriceDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type ProductVariantPriceDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
  taxIncluded: Boolean
}

input ProductVariantPriceFilter {
  and: [ProductVariantPriceFilter!]
  or: [ProductVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
  store: ProductVariantPriceFilterStoreFilter
  variant: ProductVariantPriceFilterProductVariantFilter
}

input ProductVariantPriceFilterProductVariantFilter {
  and: [ProductVariantPriceFilterProductVariantFilter!]
  or: [ProductVariantPriceFilterProductVariantFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
}

input ProductVariantPriceFilterStoreFilter {
  and: [ProductVariantPriceFilterStoreFilter!]
  or: [ProductVariantPriceFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type ProductVariantPriceMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type ProductVariantPriceMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type ProductVariantPricesAggregateResponse {
  count: ProductVariantPricesCountAggregate
  sum: ProductVariantPricesSumAggregate
  avg: ProductVariantPricesAvgAggregate
  min: ProductVariantPricesMinAggregate
  max: ProductVariantPricesMaxAggregate
}

type ProductVariantPricesAvgAggregate {
  price: Float
}

type ProductVariantPricesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  price: Int
  taxIncluded: Int
}

type ProductVariantPricesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type ProductVariantPricesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

input ProductVariantPriceSort {
  field: ProductVariantPriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductVariantPriceSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  price
  taxIncluded
}

type ProductVariantPricesSumAggregate {
  price: Float
}

input ProductVariantPriceSubscriptionFilter {
  and: [ProductVariantPriceSubscriptionFilter!]
  or: [ProductVariantPriceSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type ProductVariantPriceSumAggregate {
  price: Float
}

input ProductVariantPriceUpdateFilter {
  and: [ProductVariantPriceUpdateFilter!]
  or: [ProductVariantPriceUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type ProductVariantsAggregateResponse {
  count: ProductVariantsCountAggregate
  sum: ProductVariantsSumAggregate
  avg: ProductVariantsAvgAggregate
  min: ProductVariantsMinAggregate
  max: ProductVariantsMaxAggregate
}

type ProductVariantsAvgAggregate {
  dum_price: Float
  rating: Float
}

type ProductVariantsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  dum_price: Int
  enabled: Int
  sku: Int
  name: Int
  rating: Int
  trackInventory: Int
}

type ProductVariantsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

type ProductVariantsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  dum_price: Float
  sku: String
  name: String
  rating: Float
}

input ProductVariantSort {
  field: ProductVariantSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ProductVariantSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  dum_price
  enabled
  sku
  name
  rating
  trackInventory
}

type ProductVariantSpecs {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  specs: JSON!
}

type ProductVariantsSumAggregate {
  dum_price: Float
  rating: Float
}

type ProductVariantStocksAggregateResponse {
  count: ProductVariantStocksCountAggregate
  sum: ProductVariantStocksSumAggregate
  avg: ProductVariantStocksAvgAggregate
  min: ProductVariantStocksMinAggregate
  max: ProductVariantStocksMaxAggregate
}

type ProductVariantStocksAvgAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

type ProductVariantStocksCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
  available_quantity: Int
  threshold: Int
  multiple: Int
  backorder: Int
  stockstatus: Int
  sku: Int
  type: Int
}

type ProductVariantStocksMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type ProductVariantStocksMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type ProductVariantStocksSumAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

input ProductVariantSubscriptionFilter {
  and: [ProductVariantSubscriptionFilter!]
  or: [ProductVariantSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  dum_price: NumberFieldComparison
  enabled: BooleanFieldComparison
  sku: StringFieldComparison
  name: StringFieldComparison
  rating: NumberFieldComparison
  trackInventory: BooleanFieldComparison
}

type ProductVariantSumAggregate {
  dum_price: Float
  rating: Float
}

type PromotionVariantPrice {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  priceType: PricePromoType!
  value: Float!
  forever: Boolean!
  startsAt: DateTime!
  endsAt: DateTime!
  enabled: Boolean!
  price: ProductVariantPrice!
}

input PromotionVariantPriceAggregateFilter {
  and: [PromotionVariantPriceAggregateFilter!]
  or: [PromotionVariantPriceAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
  forever: BooleanFieldComparison
  startsAt: DateFieldComparison
  endsAt: DateFieldComparison
  enabled: BooleanFieldComparison
}

type PromotionVariantPriceAggregateResponse {
  count: PromotionVariantPriceCountAggregate
  sum: PromotionVariantPriceSumAggregate
  avg: PromotionVariantPriceAvgAggregate
  min: PromotionVariantPriceMinAggregate
  max: PromotionVariantPriceMaxAggregate
}

type PromotionVariantPriceAvgAggregate {
  value: Float
}

type PromotionVariantPriceCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  priceType: Int
  value: Int
  forever: Int
  startsAt: Int
  endsAt: Int
  enabled: Int
}

input PromotionVariantPriceDeleteFilter {
  and: [PromotionVariantPriceDeleteFilter!]
  or: [PromotionVariantPriceDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
  forever: BooleanFieldComparison
  startsAt: DateFieldComparison
  endsAt: DateFieldComparison
  enabled: BooleanFieldComparison
}

type PromotionVariantPriceDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
  forever: Boolean
  startsAt: DateTime
  endsAt: DateTime
  enabled: Boolean
}

input PromotionVariantPriceFilter {
  and: [PromotionVariantPriceFilter!]
  or: [PromotionVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
  forever: BooleanFieldComparison
  startsAt: DateFieldComparison
  endsAt: DateFieldComparison
  enabled: BooleanFieldComparison
  price: PromotionVariantPriceFilterProductVariantPriceFilter
}

input PromotionVariantPriceFilterProductVariantPriceFilter {
  and: [PromotionVariantPriceFilterProductVariantPriceFilter!]
  or: [PromotionVariantPriceFilterProductVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

type PromotionVariantPriceMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
  startsAt: DateTime
  endsAt: DateTime
}

type PromotionVariantPriceMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
  startsAt: DateTime
  endsAt: DateTime
}

input PromotionVariantPriceSort {
  field: PromotionVariantPriceSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PromotionVariantPriceSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  priceType
  value
  forever
  startsAt
  endsAt
  enabled
}

input PromotionVariantPriceSubscriptionFilter {
  and: [PromotionVariantPriceSubscriptionFilter!]
  or: [PromotionVariantPriceSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
  forever: BooleanFieldComparison
  startsAt: DateFieldComparison
  endsAt: DateFieldComparison
  enabled: BooleanFieldComparison
}

type PromotionVariantPriceSumAggregate {
  value: Float
}

input PromotionVariantPriceUpdateFilter {
  and: [PromotionVariantPriceUpdateFilter!]
  or: [PromotionVariantPriceUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  priceType: PricePromoTypeFilterComparison
  value: NumberFieldComparison
  forever: BooleanFieldComparison
  startsAt: DateFieldComparison
  endsAt: DateFieldComparison
  enabled: BooleanFieldComparison
}

type Query {
  GetAdministratorData: Administrator!
  GetAllAdministrator(search: String): [Administrator!]!
  asset(
    """The id of the record to find."""
    id: ID!
  ): Asset
  assets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: AssetFilter = {}

    """Specify to sort results."""
    sorting: [AssetSort!] = []
  ): [Asset!]!
  assetAggregate(
    """Filter to find records to aggregate on"""
    filter: AssetAggregateFilter
  ): AssetAggregateResponse!
  role(
    """The id of the record to find."""
    id: ID!
  ): Role
  roles(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: RoleFilter = {}

    """Specify to sort results."""
    sorting: [RoleSort!] = []
  ): [Role!]!
  roleAggregate(
    """Filter to find records to aggregate on"""
    filter: RoleAggregateFilter
  ): RoleAggregateResponse!
  collection(
    """The id of the record to find."""
    id: ID!
  ): Collection
  collections(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CollectionFilter = {}

    """Specify to sort results."""
    sorting: [CollectionSort!] = []
  ): [Collection!]!
  collectionAggregate(
    """Filter to find records to aggregate on"""
    filter: CollectionAggregateFilter
  ): CollectionAggregateResponse!
  GetCollectionTree: [Collection!]!
  channel(
    """The id of the record to find."""
    id: ID!
  ): Channel
  channels(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ChannelFilter = {}

    """Specify to sort results."""
    sorting: [ChannelSort!] = []
  ): [Channel!]!
  channelAggregate(
    """Filter to find records to aggregate on"""
    filter: ChannelAggregateFilter
  ): ChannelAggregateResponse!
  store(
    """The id of the record to find."""
    id: ID!
  ): Store
  stores(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StoreFilter = {}

    """Specify to sort results."""
    sorting: [StoreSort!] = []
  ): [Store!]!
  storeAggregate(
    """Filter to find records to aggregate on"""
    filter: StoreAggregateFilter
  ): StoreAggregateResponse!
  GetDefaultStore: Store
  taxCategory(
    """The id of the record to find."""
    id: ID!
  ): TaxCategory
  taxCategories(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxCategoryFilter = {}

    """Specify to sort results."""
    sorting: [TaxCategorySort!] = []
  ): [TaxCategory!]!
  taxCategoryAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxCategoryAggregateFilter
  ): TaxCategoryAggregateResponse!
  taxRate(
    """The id of the record to find."""
    id: ID!
  ): TaxRate
  taxRates(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxRateFilter = {}

    """Specify to sort results."""
    sorting: [TaxRateSort!] = []
  ): [TaxRate!]!
  taxRateAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxRateAggregateFilter
  ): TaxRateAggregateResponse!
  GetAllTaxRates: [TaxRate!]!
  GetAllTaxCategory: [TaxCategory!]!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  users(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): [User!]!
  userAggregate(
    """Filter to find records to aggregate on"""
    filter: UserAggregateFilter
  ): UserAggregateResponse!
  GetCurrentUser: User!
  vendor(
    """The id of the record to find."""
    id: ID!
  ): Vendor
  vendors(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorFilter = {}

    """Specify to sort results."""
    sorting: [VendorSort!] = []
  ): [Vendor!]!
  vendorAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorAggregateFilter
  ): VendorAggregateResponse!
  GetVendorInfo: Vendor
  zone(
    """The id of the record to find."""
    id: ID!
  ): Zone
  zones(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZoneFilter = {}

    """Specify to sort results."""
    sorting: [ZoneSort!] = []
  ): [Zone!]!
  zoneAggregate(
    """Filter to find records to aggregate on"""
    filter: ZoneAggregateFilter
  ): ZoneAggregateResponse!
  ZoneFindMany: [Zone!]!
  ZoneFindOne(id: ID!): Zone!
  country(
    """The id of the record to find."""
    id: ID!
  ): Country
  countries(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CountryFilter = {}

    """Specify to sort results."""
    sorting: [CountrySort!] = []
  ): [Country!]!
  countryAggregate(
    """Filter to find records to aggregate on"""
    filter: CountryAggregateFilter
  ): CountryAggregateResponse!
  GetAllCountries: [Country!]!
  seo(
    """The id of the record to find."""
    id: ID!
  ): Seo
  seos(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: SeoFilter = {}

    """Specify to sort results."""
    sorting: [SeoSort!] = []
  ): [Seo!]!
  seoAggregate(
    """Filter to find records to aggregate on"""
    filter: SeoAggregateFilter
  ): SeoAggregateResponse!
  facet(
    """The id of the record to find."""
    id: ID!
  ): Facet
  facets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: FacetFilter = {}

    """Specify to sort results."""
    sorting: [FacetSort!] = []
  ): [Facet!]!
  facetAggregate(
    """Filter to find records to aggregate on"""
    filter: FacetAggregateFilter
  ): FacetAggregateResponse!
  facetValue(
    """The id of the record to find."""
    id: ID!
  ): FacetValue
  facetValues(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: FacetValueFilter = {}

    """Specify to sort results."""
    sorting: [FacetValueSort!] = []
  ): [FacetValue!]!
  facetValueAggregate(
    """Filter to find records to aggregate on"""
    filter: FacetValueAggregateFilter
  ): FacetValueAggregateResponse!
  product(
    """The id of the record to find."""
    id: ID!
  ): Product
  products(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]!
  productAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): ProductAggregateResponse!
  productVariant(
    """The id of the record to find."""
    id: ID!
  ): ProductVariant
  productVariants(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantSort!] = []
  ): [ProductVariant!]!
  productVariantAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantAggregateFilter
  ): ProductVariantAggregateResponse!
  productOption(
    """The id of the record to find."""
    id: ID!
  ): ProductOption
  productOptions(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductOptionFilter = {}

    """Specify to sort results."""
    sorting: [ProductOptionSort!] = []
  ): [ProductOption!]!
  productOptionAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductOptionAggregateFilter
  ): ProductOptionAggregateResponse!
  productOptionGroup(
    """The id of the record to find."""
    id: ID!
  ): ProductOptionGroup
  productOptionGroups(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductOptionGroupFilter = {}

    """Specify to sort results."""
    sorting: [ProductOptionGroupSort!] = []
  ): [ProductOptionGroup!]!
  productOptionGroupAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductOptionGroupAggregateFilter
  ): ProductOptionGroupAggregateResponse!
  productVariantPrice(
    """The id of the record to find."""
    id: ID!
  ): ProductVariantPrice
  productVariantPrices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantPriceSort!] = []
  ): [ProductVariantPrice!]!
  productVariantPriceAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantPriceAggregateFilter
  ): ProductVariantPriceAggregateResponse!
  GetPriceForVariant(prodId: ID, storeId: ID): ProductVariantPrice
  productVariantAsset(
    """The id of the record to find."""
    id: ID!
  ): ProductVariantAsset
  productVariantAssets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantAssetFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantAssetSort!] = []
  ): [ProductVariantAsset!]!
  productVariantAssetAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantAssetAggregateFilter
  ): ProductVariantAssetAggregateResponse!
  productAsset(
    """The id of the record to find."""
    id: ID!
  ): ProductAsset
  productAssets(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductAssetFilter = {}

    """Specify to sort results."""
    sorting: [ProductAssetSort!] = []
  ): [ProductAsset!]!
  productAssetAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAssetAggregateFilter
  ): ProductAssetAggregateResponse!
  vendorPlans(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorPlansFilter = {}

    """Specify to sort results."""
    sorting: [VendorPlansSort!] = []
  ): [VendorPlans!]!
  vendorPlansAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorPlansAggregateFilter
  ): VendorPlansAggregateResponse!
  FindAllVendorPlans: [VendorPlans!]!
  GetVendorPlansForRegistration: [VendorPlans!]!
  vendorLicense(
    """The id of the record to find."""
    id: ID!
  ): VendorLicense
  vendorLicenses(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorLicenseFilter = {}

    """Specify to sort results."""
    sorting: [VendorLicenseSort!] = []
  ): [VendorLicense!]!
  vendorLicenseAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorLicenseAggregateFilter
  ): VendorLicenseAggregateResponse!
  GetBillingAgreementByVendor: [BillingAgreement!]!
  GetBillingAgreement(id: ID!): BillingAgreement!
  GetBillingRequestForAgreement(id: String!): [BillingAgreementRequest!]!
  GetBillingAgreementForStore(variantId: String!, storeId: String!): BillingAgreement!
  stockKeeping(
    """The id of the record to find."""
    id: ID!
  ): StockKeeping
  stockKeepings(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockKeepingFilter = {}

    """Specify to sort results."""
    sorting: [StockKeepingSort!] = []
  ): [StockKeeping!]!
  stockKeepingAggregate(
    """Filter to find records to aggregate on"""
    filter: StockKeepingAggregateFilter
  ): StockKeepingAggregateResponse!
  getStockKeepingVendor(vendorId: ID, variantId: ID!): StockKeeping
  getStockKeepingByStore: [StockKeeping!]!
  sale(
    """The id of the record to find."""
    id: ID!
  ): Sale
  sales(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: SaleFilter = {}

    """Specify to sort results."""
    sorting: [SaleSort!] = []
  ): [Sale!]!
  saleAggregate(
    """Filter to find records to aggregate on"""
    filter: SaleAggregateFilter
  ): SaleAggregateResponse!
  stockMovement(
    """The id of the record to find."""
    id: ID!
  ): StockMovement
  stockMovements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockMovementFilter = {}

    """Specify to sort results."""
    sorting: [StockMovementSort!] = []
  ): [StockMovement!]!
  stockMovementAggregate(
    """Filter to find records to aggregate on"""
    filter: StockMovementAggregateFilter
  ): StockMovementAggregateResponse!
  cancellation(
    """The id of the record to find."""
    id: ID!
  ): Cancellation
  cancellations(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CancellationFilter = {}

    """Specify to sort results."""
    sorting: [CancellationSort!] = []
  ): [Cancellation!]!
  cancellationAggregate(
    """Filter to find records to aggregate on"""
    filter: CancellationAggregateFilter
  ): CancellationAggregateResponse!
  order(
    """The id of the record to find."""
    id: ID!
  ): Order
  orders(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter = {}

    """Specify to sort results."""
    sorting: [OrderSort!] = []
  ): [Order!]!
  orderAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): OrderAggregateResponse!
  zip(
    """The id of the record to find."""
    id: ID!
  ): Zip
  zips(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZipFilter = {}

    """Specify to sort results."""
    sorting: [ZipSort!] = []
  ): [Zip!]!
  zipAggregate(
    """Filter to find records to aggregate on"""
    filter: ZipAggregateFilter
  ): ZipAggregateResponse!
  findAllZip: [Zip!]!
  menu(
    """The id of the record to find."""
    id: ID!
  ): Menu
  menus(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: MenuFilter = {}

    """Specify to sort results."""
    sorting: [MenuSort!] = []
  ): [Menu!]!
  menuAggregate(
    """Filter to find records to aggregate on"""
    filter: MenuAggregateFilter
  ): MenuAggregateResponse!
  GetMenuTree: MenuResponseTypes!
  page(
    """The id of the record to find."""
    id: ID!
  ): Page
  pages(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: PageFilter = {}

    """Specify to sort results."""
    sorting: [PageSort!] = []
  ): [Page!]!
  pageAggregate(
    """Filter to find records to aggregate on"""
    filter: PageAggregateFilter
  ): PageAggregateResponse!
  getHomePage: Page!
  address(
    """The id of the record to find."""
    id: ID!
  ): Address
  addresses(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: AddressFilter = {}

    """Specify to sort results."""
    sorting: [AddressSort!] = []
  ): [Address!]!
  addressAggregate(
    """Filter to find records to aggregate on"""
    filter: AddressAggregateFilter
  ): AddressAggregateResponse!
  settlements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: SettlementsFilter = {}

    """Specify to sort results."""
    sorting: [SettlementsSort!] = []
  ): [Settlements!]!
  settlementsAggregate(
    """Filter to find records to aggregate on"""
    filter: SettlementsAggregateFilter
  ): SettlementsAggregateResponse!
  orderLine(
    """The id of the record to find."""
    id: ID!
  ): OrderLine
  orderLines(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderLineFilter = {}

    """Specify to sort results."""
    sorting: [OrderLineSort!] = []
  ): [OrderLine!]!
  orderLineAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderLineAggregateFilter
  ): OrderLineAggregateResponse!
  orderItem(
    """The id of the record to find."""
    id: ID!
  ): OrderItem
  orderItems(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderItemFilter = {}

    """Specify to sort results."""
    sorting: [OrderItemSort!] = []
  ): [OrderItem!]!
  orderItemAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderItemAggregateFilter
  ): OrderItemAggregateResponse!
  promotionVariantPrice(
    """The id of the record to find."""
    id: ID!
  ): PromotionVariantPrice
  promotionVariantPrices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: PromotionVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [PromotionVariantPriceSort!] = []
  ): [PromotionVariantPrice!]!
  promotionVariantPriceAggregate(
    """Filter to find records to aggregate on"""
    filter: PromotionVariantPriceAggregateFilter
  ): PromotionVariantPriceAggregateResponse!
  GetPromotionsPrices: [ProductVariantPrice!]!
  cartPriceRules(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CartPriceRulesFilter = {}

    """Specify to sort results."""
    sorting: [CartPriceRulesSort!] = []
  ): [CartPriceRules!]!
  cartPriceRulesAggregate(
    """Filter to find records to aggregate on"""
    filter: CartPriceRulesAggregateFilter
  ): CartPriceRulesAggregateResponse!
  account(
    """The id of the record to find."""
    id: ID!
  ): Account
  accounts(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: AccountFilter = {}

    """Specify to sort results."""
    sorting: [AccountSort!] = []
  ): [Account!]!
  accountAggregate(
    """Filter to find records to aggregate on"""
    filter: AccountAggregateFilter
  ): AccountAggregateResponse!
  GetVendorAccount: Account!
  delivery(
    """The id of the record to find."""
    id: ID!
  ): Delivery
  deliveries(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: DeliveryFilter = {}

    """Specify to sort results."""
    sorting: [DeliverySort!] = []
  ): [Delivery!]!
  deliveryAggregate(
    """Filter to find records to aggregate on"""
    filter: DeliveryAggregateFilter
  ): DeliveryAggregateResponse!
  GetPoolStrength: [DeliveryPool!]!
  GetDeliveryStrandedCount: DeliveryStrandedCount!
  GetAllPaymentMethods: [PaymentMethod!]!
  GetDefaultPaymentMethods: PaymentMethod!
  GetProductSaleData(storeId: String, type: String!, productId: ID!): StatisticeDto!
  GetStoreOrderData(storeId: String!, type: String!): StatisticeDto!
  GetAdminOrderData(type: String!): StatisticeDto!
  GetProductViews(type: String, productId: ID!): StatisticeProdDto!
  GetAdminViews(type: String): StatisticeProdDto!
  stockBackLog(
    """The id of the record to find."""
    id: ID!
  ): StockBackLog
  stockBackLogs(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockBackLogFilter = {}

    """Specify to sort results."""
    sorting: [StockBackLogSort!] = []
  ): [StockBackLog!]!
  stockBackLogAggregate(
    """Filter to find records to aggregate on"""
    filter: StockBackLogAggregateFilter
  ): StockBackLogAggregateResponse!
  invoice(
    """The id of the record to find."""
    id: ID!
  ): Invoice
  invoices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): [Invoice!]!
  invoiceAggregate(
    """Filter to find records to aggregate on"""
    filter: InvoiceAggregateFilter
  ): InvoiceAggregateResponse!
  refund(
    """The id of the record to find."""
    id: ID!
  ): Refund
  refunds(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: RefundFilter = {}

    """Specify to sort results."""
    sorting: [RefundSort!] = []
  ): [Refund!]!
  refundAggregate(
    """Filter to find records to aggregate on"""
    filter: RefundAggregateFilter
  ): RefundAggregateResponse!
  payment(
    """The id of the record to find."""
    id: ID!
  ): Payment
  payments(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: PaymentFilter = {}

    """Specify to sort results."""
    sorting: [PaymentSort!] = []
  ): [Payment!]!
  paymentAggregate(
    """Filter to find records to aggregate on"""
    filter: PaymentAggregateFilter
  ): PaymentAggregateResponse!
  viewCode(
    """The id of the record to find."""
    id: ID!
  ): ViewCode
  viewCodes(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ViewCodeFilter = {}

    """Specify to sort results."""
    sorting: [ViewCodeSort!] = []
  ): [ViewCode!]!
  viewCodeAggregate(
    """Filter to find records to aggregate on"""
    filter: ViewCodeAggregateFilter
  ): ViewCodeAggregateResponse!
  hsn(
    """The id of the record to find."""
    id: ID!
  ): Hsn
  hsns(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: HsnFilter = {}

    """Specify to sort results."""
    sorting: [HsnSort!] = []
  ): [Hsn!]!
  hsnAggregate(
    """Filter to find records to aggregate on"""
    filter: HsnAggregateFilter
  ): HsnAggregateResponse!
  serviceable(
    """The id of the record to find."""
    id: ID!
  ): Serviceable
  serviceables(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ServiceableFilter = {}

    """Specify to sort results."""
    sorting: [ServiceableSort!] = []
  ): [Serviceable!]!
  serviceableAggregate(
    """Filter to find records to aggregate on"""
    filter: ServiceableAggregateFilter
  ): ServiceableAggregateResponse!
}

type Refund {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  reason: String!
  destination: String!
  transactionId: String!
  stage: RefundEnum!
  line: OrderLine!
}

input RefundAggregateFilter {
  and: [RefundAggregateFilter!]
  or: [RefundAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  reason: StringFieldComparison
  destination: StringFieldComparison
  transactionId: StringFieldComparison
  stage: RefundEnumFilterComparison
}

type RefundAggregateResponse {
  count: RefundCountAggregate
  min: RefundMinAggregate
  max: RefundMaxAggregate
}

type RefundCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  reason: Int
  destination: Int
  transactionId: Int
  stage: Int
}

type RefundDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  reason: String
  destination: String
  transactionId: String
  stage: RefundEnum
}

enum RefundEnum {
  INITIATED
  REFUNDED
}

input RefundEnumFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: RefundEnum
  neq: RefundEnum
  gt: RefundEnum
  gte: RefundEnum
  lt: RefundEnum
  lte: RefundEnum
  like: RefundEnum
  notLike: RefundEnum
  iLike: RefundEnum
  notILike: RefundEnum
  in: [RefundEnum!]
  notIn: [RefundEnum!]
}

input RefundFilter {
  and: [RefundFilter!]
  or: [RefundFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  reason: StringFieldComparison
  destination: StringFieldComparison
  transactionId: StringFieldComparison
  stage: RefundEnumFilterComparison
  line: RefundFilterOrderLineFilter
}

input RefundFilterOrderLineFilter {
  and: [RefundFilterOrderLineFilter!]
  or: [RefundFilterOrderLineFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  stage: OrderStageTypeFilterComparison
}

type RefundMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  reason: String
  destination: String
  transactionId: String
  stage: RefundEnum
}

type RefundMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  reason: String
  destination: String
  transactionId: String
  stage: RefundEnum
}

input RefundSort {
  field: RefundSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RefundSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  reason
  destination
  transactionId
  stage
}

input RefundSubscriptionFilter {
  and: [RefundSubscriptionFilter!]
  or: [RefundSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  reason: StringFieldComparison
  destination: StringFieldComparison
  transactionId: StringFieldComparison
  stage: RefundEnumFilterComparison
}

input RefundUpdateFilter {
  and: [RefundUpdateFilter!]
  or: [RefundUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  reason: StringFieldComparison
  destination: StringFieldComparison
  transactionId: StringFieldComparison
  stage: RefundEnumFilterComparison
}

input RelationInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RelationsInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

type ResetCode {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  code: String!
  user: User!
}

type Review {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  stars: Int!
  text: String!
  user: User!
  variant: ProductVariant!
}

type Role {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  code: String!
  description: String!
  permissions: [Permission!]!
  type: RoleType!
}

input RoleAggregateFilter {
  and: [RoleAggregateFilter!]
  or: [RoleAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  description: StringFieldComparison
}

type RoleAggregateResponse {
  count: RoleCountAggregate
  min: RoleMinAggregate
  max: RoleMaxAggregate
}

type RoleCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
  description: Int
}

type RoleDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  description: String
  permissions: [Permission!]
  type: RoleType
}

input RoleFilter {
  and: [RoleFilter!]
  or: [RoleFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  description: StringFieldComparison
}

type RoleMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  description: String
}

type RoleMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  description: String
}

input RoleSort {
  field: RoleSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum RoleSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  code
  description
}

input RoleSubscriptionFilter {
  and: [RoleSubscriptionFilter!]
  or: [RoleSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  code: StringFieldComparison
  description: StringFieldComparison
}

enum RoleType {
  ADMINISTRATOR
  VENDOR
  USER
  BASIC
}

type Sale {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Float!
  keeping: StockKeeping!
}

input SaleAggregateFilter {
  and: [SaleAggregateFilter!]
  or: [SaleAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type SaleAggregateResponse {
  count: SaleCountAggregate
  sum: SaleSumAggregate
  avg: SaleAvgAggregate
  min: SaleMinAggregate
  max: SaleMaxAggregate
}

type SaleAvgAggregate {
  quantity: Float
}

type SaleCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

input SaleDeleteFilter {
  and: [SaleDeleteFilter!]
  or: [SaleDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type SaleDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input SaleFilter {
  and: [SaleFilter!]
  or: [SaleFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type SaleMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type SaleMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input SaleSort {
  field: SaleSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SaleSortFields {
  id
  createdAt
  updatedAt
  quantity
}

input SaleSubscriptionFilter {
  and: [SaleSubscriptionFilter!]
  or: [SaleSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type SaleSumAggregate {
  quantity: Float
}

input SaleUpdateFilter {
  and: [SaleUpdateFilter!]
  or: [SaleUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type Seo {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  urlKey: String!
  metatitle: String!
  metakeywords: [String!]
  metadesc: String!
  variant: ProductVariant
  collection: Collection
}

input SeoAggregateFilter {
  and: [SeoAggregateFilter!]
  or: [SeoAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  urlKey: StringFieldComparison
  metatitle: StringFieldComparison
}

type SeoAggregateResponse {
  count: SeoCountAggregate
  min: SeoMinAggregate
  max: SeoMaxAggregate
}

type SeoCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  urlKey: Int
  metatitle: Int
}

input SeoDeleteFilter {
  and: [SeoDeleteFilter!]
  or: [SeoDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  urlKey: StringFieldComparison
  metatitle: StringFieldComparison
}

type SeoDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  urlKey: String
  metatitle: String
  metakeywords: [String!]
  metadesc: String
}

input SeoFilter {
  and: [SeoFilter!]
  or: [SeoFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  urlKey: StringFieldComparison
  metatitle: StringFieldComparison
}

type SeoMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  urlKey: String
  metatitle: String
}

type SeoMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  urlKey: String
  metatitle: String
}

input SeoSort {
  field: SeoSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SeoSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  urlKey
  metatitle
}

input SeoSubscriptionFilter {
  and: [SeoSubscriptionFilter!]
  or: [SeoSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  urlKey: StringFieldComparison
  metatitle: StringFieldComparison
}

input SeoUpdateFilter {
  and: [SeoUpdateFilter!]
  or: [SeoUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  urlKey: StringFieldComparison
  metatitle: StringFieldComparison
}

type Serviceable {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  type: ServiceableTypes!
  mode: ServiceableOrderTypes!
  products(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductFilter = {}

    """Specify to sort results."""
    sorting: [ProductSort!] = []
  ): [Product!]
  vendors(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorFilter = {}

    """Specify to sort results."""
    sorting: [VendorSort!] = []
  ): [Vendor!]
  productsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductAggregateFilter
  ): ServiceableProductsAggregateResponse!
  vendorsAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorAggregateFilter
  ): ServiceableVendorsAggregateResponse!
}

input ServiceableAggregateFilter {
  and: [ServiceableAggregateFilter!]
  or: [ServiceableAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  type: ServiceableTypesFilterComparison
  mode: ServiceableOrderTypesFilterComparison
}

type ServiceableAggregateResponse {
  count: ServiceableCountAggregate
  min: ServiceableMinAggregate
  max: ServiceableMaxAggregate
}

type ServiceableCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  type: Int
  mode: Int
}

input ServiceableDeleteFilter {
  and: [ServiceableDeleteFilter!]
  or: [ServiceableDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  type: ServiceableTypesFilterComparison
  mode: ServiceableOrderTypesFilterComparison
}

type ServiceableDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  type: ServiceableTypes
  mode: ServiceableOrderTypes
}

input ServiceableFilter {
  and: [ServiceableFilter!]
  or: [ServiceableFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  type: ServiceableTypesFilterComparison
  mode: ServiceableOrderTypesFilterComparison
  product: ServiceableFilterProductFilter
  vendors: ServiceableFilterVendorFilter
}

input ServiceableFilterProductFilter {
  and: [ServiceableFilterProductFilter!]
  or: [ServiceableFilterProductFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  productName: StringFieldComparison
  slug: StringFieldComparison
  description: StringFieldComparison
}

input ServiceableFilterVendorFilter {
  and: [ServiceableFilterVendorFilter!]
  or: [ServiceableFilterVendorFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  vendorName: StringFieldComparison
  phoneNumber: StringFieldComparison
  email: StringFieldComparison
}

type ServiceableMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  type: ServiceableTypes
  mode: ServiceableOrderTypes
}

type ServiceableMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  type: ServiceableTypes
  mode: ServiceableOrderTypes
}

type ServiceableOrders {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  dateTime: DateTime!
}

enum ServiceableOrderTypes {
  IMMEDIATE
  DATE
}

input ServiceableOrderTypesFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ServiceableOrderTypes
  neq: ServiceableOrderTypes
  gt: ServiceableOrderTypes
  gte: ServiceableOrderTypes
  lt: ServiceableOrderTypes
  lte: ServiceableOrderTypes
  like: ServiceableOrderTypes
  notLike: ServiceableOrderTypes
  iLike: ServiceableOrderTypes
  notILike: ServiceableOrderTypes
  in: [ServiceableOrderTypes!]
  notIn: [ServiceableOrderTypes!]
}

type ServiceableProductsAggregateResponse {
  count: ServiceableProductsCountAggregate
  min: ServiceableProductsMinAggregate
  max: ServiceableProductsMaxAggregate
}

type ServiceableProductsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  productName: Int
  slug: Int
  description: Int
}

type ServiceableProductsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

type ServiceableProductsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
}

input ServiceableSort {
  field: ServiceableSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ServiceableSortFields {
  id
  createdAt
  updatedAt
  name
  type
  mode
}

input ServiceableSubscriptionFilter {
  and: [ServiceableSubscriptionFilter!]
  or: [ServiceableSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  type: ServiceableTypesFilterComparison
  mode: ServiceableOrderTypesFilterComparison
}

enum ServiceableTypes {
  VENDOR
  PRODUCT
}

input ServiceableTypesFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ServiceableTypes
  neq: ServiceableTypes
  gt: ServiceableTypes
  gte: ServiceableTypes
  lt: ServiceableTypes
  lte: ServiceableTypes
  like: ServiceableTypes
  notLike: ServiceableTypes
  iLike: ServiceableTypes
  notILike: ServiceableTypes
  in: [ServiceableTypes!]
  notIn: [ServiceableTypes!]
}

input ServiceableUpdateFilter {
  and: [ServiceableUpdateFilter!]
  or: [ServiceableUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  type: ServiceableTypesFilterComparison
  mode: ServiceableOrderTypesFilterComparison
}

type ServiceableVendorsAggregateResponse {
  count: ServiceableVendorsCountAggregate
  min: ServiceableVendorsMinAggregate
  max: ServiceableVendorsMaxAggregate
}

type ServiceableVendorsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  vendorName: Int
  phoneNumber: Int
  email: Int
}

type ServiceableVendorsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

type ServiceableVendorsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

type Settlements {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  amount: Float!
  taxamount: Float!
  finalamount: Float!
  transactionID: String!
  remarks: String!
  type: SettlementType!
  store: Store!
}

input SettlementsAggregateFilter {
  and: [SettlementsAggregateFilter!]
  or: [SettlementsAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  taxamount: NumberFieldComparison
  finalamount: NumberFieldComparison
  transactionID: StringFieldComparison
  remarks: StringFieldComparison
  type: SettlementTypeFilterComparison
}

type SettlementsAggregateResponse {
  count: SettlementsCountAggregate
  sum: SettlementsSumAggregate
  avg: SettlementsAvgAggregate
  min: SettlementsMinAggregate
  max: SettlementsMaxAggregate
}

type SettlementsAvgAggregate {
  amount: Float
  taxamount: Float
  finalamount: Float
}

type SettlementsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  amount: Int
  taxamount: Int
  finalamount: Int
  transactionID: Int
  remarks: Int
  type: Int
}

type SettlementsDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  taxamount: Float
  finalamount: Float
  transactionID: String
  remarks: String
  type: SettlementType
}

input SettlementsFilter {
  and: [SettlementsFilter!]
  or: [SettlementsFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  taxamount: NumberFieldComparison
  finalamount: NumberFieldComparison
  transactionID: StringFieldComparison
  remarks: StringFieldComparison
  type: SettlementTypeFilterComparison
}

type SettlementsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  taxamount: Float
  finalamount: Float
  transactionID: String
  remarks: String
  type: SettlementType
}

type SettlementsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  taxamount: Float
  finalamount: Float
  transactionID: String
  remarks: String
  type: SettlementType
}

input SettlementsSort {
  field: SettlementsSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum SettlementsSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  amount
  taxamount
  finalamount
  transactionID
  remarks
  type
}

input SettlementsSubscriptionFilter {
  and: [SettlementsSubscriptionFilter!]
  or: [SettlementsSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  taxamount: NumberFieldComparison
  finalamount: NumberFieldComparison
  transactionID: StringFieldComparison
  remarks: StringFieldComparison
  type: SettlementTypeFilterComparison
}

type SettlementsSumAggregate {
  amount: Float
  taxamount: Float
  finalamount: Float
}

enum SettlementType {
  PROCESSING
  PROCESSED
}

input SettlementTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: SettlementType
  neq: SettlementType
  gt: SettlementType
  gte: SettlementType
  lt: SettlementType
  lte: SettlementType
  like: SettlementType
  notLike: SettlementType
  iLike: SettlementType
  notILike: SettlementType
  in: [SettlementType!]
  notIn: [SettlementType!]
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type StatisticeDto {
  labels: [String!]!
  datasource: [DataSource!]!
}

type StatisticeProdDto {
  labels: [String!]!
  datasource: [ProdDataSource!]!
}

type StockBackLog {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Float!
  store: Store
  variant: ProductVariantPrice
}

input StockBackLogAggregateFilter {
  and: [StockBackLogAggregateFilter!]
  or: [StockBackLogAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockBackLogAggregateResponse {
  count: StockBackLogCountAggregate
  sum: StockBackLogSumAggregate
  avg: StockBackLogAvgAggregate
  min: StockBackLogMinAggregate
  max: StockBackLogMaxAggregate
}

type StockBackLogAvgAggregate {
  quantity: Float
}

type StockBackLogCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

input StockBackLogDeleteFilter {
  and: [StockBackLogDeleteFilter!]
  or: [StockBackLogDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockBackLogDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input StockBackLogFilter {
  and: [StockBackLogFilter!]
  or: [StockBackLogFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  store: StockBackLogFilterStoreFilter
  variant: StockBackLogFilterProductVariantPriceFilter
}

input StockBackLogFilterProductVariantPriceFilter {
  and: [StockBackLogFilterProductVariantPriceFilter!]
  or: [StockBackLogFilterProductVariantPriceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  price: NumberFieldComparison
  taxIncluded: BooleanFieldComparison
}

input StockBackLogFilterStoreFilter {
  and: [StockBackLogFilterStoreFilter!]
  or: [StockBackLogFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type StockBackLogMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockBackLogMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input StockBackLogSort {
  field: StockBackLogSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum StockBackLogSortFields {
  id
  createdAt
  updatedAt
  quantity
}

input StockBackLogSubscriptionFilter {
  and: [StockBackLogSubscriptionFilter!]
  or: [StockBackLogSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockBackLogSumAggregate {
  quantity: Float
}

input StockBackLogUpdateFilter {
  and: [StockBackLogUpdateFilter!]
  or: [StockBackLogUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockKeeping {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Float!
  available_quantity: Float!
  threshold: Float!
  multiple: Boolean!
  backorder: Boolean!
  stockstatus: Boolean!
  sku: String!
  type: StockKeepingType!
  sales(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: SaleFilter = {}

    """Specify to sort results."""
    sorting: [SaleSort!] = []
  ): [Sale!]!
  cancels(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CancellationFilter = {}

    """Specify to sort results."""
    sorting: [CancellationSort!] = []
  ): [Cancellation!]!
  movements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockMovementFilter = {}

    """Specify to sort results."""
    sorting: [StockMovementSort!] = []
  ): [StockMovement!]!
  store: Store!
  variant: ProductVariant!
  salesAggregate(
    """Filter to find records to aggregate on"""
    filter: SaleAggregateFilter
  ): StockKeepingSalesAggregateResponse!
  cancelsAggregate(
    """Filter to find records to aggregate on"""
    filter: CancellationAggregateFilter
  ): StockKeepingCancelsAggregateResponse!
  movementsAggregate(
    """Filter to find records to aggregate on"""
    filter: StockMovementAggregateFilter
  ): StockKeepingMovementsAggregateResponse!
}

input StockKeepingAggregateFilter {
  and: [StockKeepingAggregateFilter!]
  or: [StockKeepingAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  available_quantity: NumberFieldComparison
  threshold: NumberFieldComparison
  multiple: BooleanFieldComparison
  backorder: BooleanFieldComparison
  stockstatus: BooleanFieldComparison
  sku: StringFieldComparison
  type: StockKeepingTypeFilterComparison
}

type StockKeepingAggregateResponse {
  count: StockKeepingCountAggregate
  sum: StockKeepingSumAggregate
  avg: StockKeepingAvgAggregate
  min: StockKeepingMinAggregate
  max: StockKeepingMaxAggregate
}

type StockKeepingAvgAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

type StockKeepingCancelsAggregateResponse {
  count: StockKeepingCancelsCountAggregate
  sum: StockKeepingCancelsSumAggregate
  avg: StockKeepingCancelsAvgAggregate
  min: StockKeepingCancelsMinAggregate
  max: StockKeepingCancelsMaxAggregate
}

type StockKeepingCancelsAvgAggregate {
  quantity: Float
}

type StockKeepingCancelsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

type StockKeepingCancelsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingCancelsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingCancelsSumAggregate {
  quantity: Float
}

type StockKeepingCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
  available_quantity: Int
  threshold: Int
  multiple: Int
  backorder: Int
  stockstatus: Int
  sku: Int
  type: Int
}

input StockKeepingDeleteFilter {
  and: [StockKeepingDeleteFilter!]
  or: [StockKeepingDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  available_quantity: NumberFieldComparison
  threshold: NumberFieldComparison
  multiple: BooleanFieldComparison
  backorder: BooleanFieldComparison
  stockstatus: BooleanFieldComparison
  sku: StringFieldComparison
  type: StockKeepingTypeFilterComparison
}

type StockKeepingDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  multiple: Boolean
  backorder: Boolean
  stockstatus: Boolean
  sku: String
  type: StockKeepingType
}

input StockKeepingFilter {
  and: [StockKeepingFilter!]
  or: [StockKeepingFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  available_quantity: NumberFieldComparison
  threshold: NumberFieldComparison
  multiple: BooleanFieldComparison
  backorder: BooleanFieldComparison
  stockstatus: BooleanFieldComparison
  sku: StringFieldComparison
  type: StockKeepingTypeFilterComparison
}

type StockKeepingMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type StockKeepingMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type StockKeepingMovementsAggregateResponse {
  count: StockKeepingMovementsCountAggregate
  sum: StockKeepingMovementsSumAggregate
  avg: StockKeepingMovementsAvgAggregate
  min: StockKeepingMovementsMinAggregate
  max: StockKeepingMovementsMaxAggregate
}

type StockKeepingMovementsAvgAggregate {
  quantity: Float
}

type StockKeepingMovementsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

type StockKeepingMovementsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingMovementsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingMovementsSumAggregate {
  quantity: Float
}

type StockKeepingSalesAggregateResponse {
  count: StockKeepingSalesCountAggregate
  sum: StockKeepingSalesSumAggregate
  avg: StockKeepingSalesAvgAggregate
  min: StockKeepingSalesMinAggregate
  max: StockKeepingSalesMaxAggregate
}

type StockKeepingSalesAvgAggregate {
  quantity: Float
}

type StockKeepingSalesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

type StockKeepingSalesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingSalesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockKeepingSalesSumAggregate {
  quantity: Float
}

input StockKeepingSort {
  field: StockKeepingSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum StockKeepingSortFields {
  id
  createdAt
  updatedAt
  quantity
  available_quantity
  threshold
  multiple
  backorder
  stockstatus
  sku
  type
}

input StockKeepingSubscriptionFilter {
  and: [StockKeepingSubscriptionFilter!]
  or: [StockKeepingSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  available_quantity: NumberFieldComparison
  threshold: NumberFieldComparison
  multiple: BooleanFieldComparison
  backorder: BooleanFieldComparison
  stockstatus: BooleanFieldComparison
  sku: StringFieldComparison
  type: StockKeepingTypeFilterComparison
}

type StockKeepingSumAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

enum StockKeepingType {
  GLOBAL
  VENDOR
}

input StockKeepingTypeFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: StockKeepingType
  neq: StockKeepingType
  gt: StockKeepingType
  gte: StockKeepingType
  lt: StockKeepingType
  lte: StockKeepingType
  like: StockKeepingType
  notLike: StockKeepingType
  iLike: StockKeepingType
  notILike: StockKeepingType
  in: [StockKeepingType!]
  notIn: [StockKeepingType!]
}

input StockKeepingUpdateFilter {
  and: [StockKeepingUpdateFilter!]
  or: [StockKeepingUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
  available_quantity: NumberFieldComparison
  threshold: NumberFieldComparison
  multiple: BooleanFieldComparison
  backorder: BooleanFieldComparison
  stockstatus: BooleanFieldComparison
  sku: StringFieldComparison
  type: StockKeepingTypeFilterComparison
}

type StockMovement {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  quantity: Float!
  keeping: StockKeeping!
}

input StockMovementAggregateFilter {
  and: [StockMovementAggregateFilter!]
  or: [StockMovementAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockMovementAggregateResponse {
  count: StockMovementCountAggregate
  sum: StockMovementSumAggregate
  avg: StockMovementAvgAggregate
  min: StockMovementMinAggregate
  max: StockMovementMaxAggregate
}

type StockMovementAvgAggregate {
  quantity: Float
}

type StockMovementCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

input StockMovementDeleteFilter {
  and: [StockMovementDeleteFilter!]
  or: [StockMovementDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockMovementDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input StockMovementFilter {
  and: [StockMovementFilter!]
  or: [StockMovementFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockMovementMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StockMovementMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input StockMovementSort {
  field: StockMovementSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum StockMovementSortFields {
  id
  createdAt
  updatedAt
  quantity
}

input StockMovementSubscriptionFilter {
  and: [StockMovementSubscriptionFilter!]
  or: [StockMovementSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type StockMovementSumAggregate {
  quantity: Float
}

input StockMovementUpdateFilter {
  and: [StockMovementUpdateFilter!]
  or: [StockMovementUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

type Store {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  storeName: String!
  phoneNumber: String!
  officialemail: String!
  zipcode: String!
  streetAddress1: String!
  streetAddress2: String!
  GSTIN: String!
  singleStore: Boolean!
  rentalStore: Boolean!
  channelMarkets: Boolean!
  services: Boolean!
  assetAPI: String!
  mainAPI: String!
  type: StoreTypeEnum!
  invoices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: InvoiceFilter = {}

    """Specify to sort results."""
    sorting: [InvoiceSort!] = []
  ): [Invoice!]!
  zips(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZipFilter = {}

    """Specify to sort results."""
    sorting: [ZipSort!] = []
  ): [Zip!]!
  backlogs(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockBackLogFilter = {}

    """Specify to sort results."""
    sorting: [StockBackLogSort!] = []
  ): [StockBackLog!]!
  carts(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CartItemFilter = {}

    """Specify to sort results."""
    sorting: [CartItemSort!] = []
  ): [CartItem!]!
  prices(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantPriceSort!] = []
  ): [ProductVariantPrice!]!
  settlements(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: SettlementsFilter = {}

    """Specify to sort results."""
    sorting: [SettlementsSort!] = []
  ): [Settlements!]!
  skus(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StockKeepingFilter = {}

    """Specify to sort results."""
    sorting: [StockKeepingSort!] = []
  ): [StockKeeping!]!
  logo: Asset
  balance: StoreBalance
  country: Country!
  invoicesAggregate(
    """Filter to find records to aggregate on"""
    filter: InvoiceAggregateFilter
  ): StoreInvoicesAggregateResponse!
  zipsAggregate(
    """Filter to find records to aggregate on"""
    filter: ZipAggregateFilter
  ): StoreZipsAggregateResponse!
  backlogsAggregate(
    """Filter to find records to aggregate on"""
    filter: StockBackLogAggregateFilter
  ): StoreBacklogsAggregateResponse!
  cartsAggregate(
    """Filter to find records to aggregate on"""
    filter: CartItemAggregateFilter
  ): StoreCartsAggregateResponse!
  pricesAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantPriceAggregateFilter
  ): StorePricesAggregateResponse!
  settlementsAggregate(
    """Filter to find records to aggregate on"""
    filter: SettlementsAggregateFilter
  ): StoreSettlementsAggregateResponse!
  skusAggregate(
    """Filter to find records to aggregate on"""
    filter: StockKeepingAggregateFilter
  ): StoreSkusAggregateResponse!
}

input StoreAggregateFilter {
  and: [StoreAggregateFilter!]
  or: [StoreAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type StoreAggregateResponse {
  count: StoreCountAggregate
  min: StoreMinAggregate
  max: StoreMaxAggregate
}

type StoreBacklogsAggregateResponse {
  count: StoreBacklogsCountAggregate
  sum: StoreBacklogsSumAggregate
  avg: StoreBacklogsAvgAggregate
  min: StoreBacklogsMinAggregate
  max: StoreBacklogsMaxAggregate
}

type StoreBacklogsAvgAggregate {
  quantity: Float
}

type StoreBacklogsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
}

type StoreBacklogsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StoreBacklogsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

type StoreBacklogsSumAggregate {
  quantity: Float
}

type StoreBalance {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  balance: Float!
  balanceVolume: Float!
}

type StoreCartsAggregateResponse {
  count: StoreCartsCountAggregate
  min: StoreCartsMinAggregate
  max: StoreCartsMaxAggregate
}

type StoreCartsCountAggregate {
  id: Int
}

type StoreCartsMaxAggregate {
  id: ID
}

type StoreCartsMinAggregate {
  id: ID
}

type StoreCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  storeName: Int
  phoneNumber: Int
  officialemail: Int
  zipcode: Int
  streetAddress1: Int
  streetAddress2: Int
  GSTIN: Int
  singleStore: Int
  rentalStore: Int
  channelMarkets: Int
  services: Int
  assetAPI: Int
  mainAPI: Int
}

input StoreDeleteFilter {
  and: [StoreDeleteFilter!]
  or: [StoreDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type StoreDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  singleStore: Boolean
  rentalStore: Boolean
  channelMarkets: Boolean
  services: Boolean
  assetAPI: String
  mainAPI: String
  type: StoreTypeEnum
}

input StoreFilter {
  and: [StoreFilter!]
  or: [StoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
  invoices: StoreFilterInvoiceFilter
  zip: StoreFilterZipFilter
  backlogs: StoreFilterStockBackLogFilter
  cart: StoreFilterCartItemFilter
  settlement: StoreFilterSettlementsFilter
}

input StoreFilterCartItemFilter {
  and: [StoreFilterCartItemFilter!]
  or: [StoreFilterCartItemFilter!]
  id: IDFilterComparison
}

input StoreFilterInvoiceFilter {
  and: [StoreFilterInvoiceFilter!]
  or: [StoreFilterInvoiceFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  type: InvoiceEnumFilterComparison
  total: NumberFieldComparison
  amount: NumberFieldComparison
  fees: NumberFieldComparison
  tax: NumberFieldComparison
  nulled: BooleanFieldComparison
}

input StoreFilterSettlementsFilter {
  and: [StoreFilterSettlementsFilter!]
  or: [StoreFilterSettlementsFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  amount: NumberFieldComparison
  taxamount: NumberFieldComparison
  finalamount: NumberFieldComparison
  transactionID: StringFieldComparison
  remarks: StringFieldComparison
  type: SettlementTypeFilterComparison
}

input StoreFilterStockBackLogFilter {
  and: [StoreFilterStockBackLogFilter!]
  or: [StoreFilterStockBackLogFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  quantity: NumberFieldComparison
}

input StoreFilterZipFilter {
  and: [StoreFilterZipFilter!]
  or: [StoreFilterZipFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type StoreInvoicesAggregateResponse {
  count: StoreInvoicesCountAggregate
  sum: StoreInvoicesSumAggregate
  avg: StoreInvoicesAvgAggregate
  min: StoreInvoicesMinAggregate
  max: StoreInvoicesMaxAggregate
}

type StoreInvoicesAvgAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type StoreInvoicesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  type: Int
  total: Int
  amount: Int
  fees: Int
  tax: Int
  nulled: Int
}

type StoreInvoicesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type StoreInvoicesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  type: InvoiceEnum
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type StoreInvoicesSumAggregate {
  total: Float
  amount: Float
  fees: Float
  tax: Float
}

type StoreMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

type StoreMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

type StorePricesAggregateResponse {
  count: StorePricesCountAggregate
  sum: StorePricesSumAggregate
  avg: StorePricesAvgAggregate
  min: StorePricesMinAggregate
  max: StorePricesMaxAggregate
}

type StorePricesAvgAggregate {
  price: Float
}

type StorePricesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  price: Int
  taxIncluded: Int
}

type StorePricesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type StorePricesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type StorePricesSumAggregate {
  price: Float
}

type StoreSettlementsAggregateResponse {
  count: StoreSettlementsCountAggregate
  sum: StoreSettlementsSumAggregate
  avg: StoreSettlementsAvgAggregate
  min: StoreSettlementsMinAggregate
  max: StoreSettlementsMaxAggregate
}

type StoreSettlementsAvgAggregate {
  amount: Float
  taxamount: Float
  finalamount: Float
}

type StoreSettlementsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  amount: Int
  taxamount: Int
  finalamount: Int
  transactionID: Int
  remarks: Int
  type: Int
}

type StoreSettlementsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  taxamount: Float
  finalamount: Float
  transactionID: String
  remarks: String
  type: SettlementType
}

type StoreSettlementsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  amount: Float
  taxamount: Float
  finalamount: Float
  transactionID: String
  remarks: String
  type: SettlementType
}

type StoreSettlementsSumAggregate {
  amount: Float
  taxamount: Float
  finalamount: Float
}

type StoreSkusAggregateResponse {
  count: StoreSkusCountAggregate
  sum: StoreSkusSumAggregate
  avg: StoreSkusAvgAggregate
  min: StoreSkusMinAggregate
  max: StoreSkusMaxAggregate
}

type StoreSkusAvgAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

type StoreSkusCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  quantity: Int
  available_quantity: Int
  threshold: Int
  multiple: Int
  backorder: Int
  stockstatus: Int
  sku: Int
  type: Int
}

type StoreSkusMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type StoreSkusMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  sku: String
  type: StockKeepingType
}

type StoreSkusSumAggregate {
  quantity: Float
  available_quantity: Float
  threshold: Float
}

input StoreSort {
  field: StoreSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum StoreSortFields {
  id
  createdAt
  updatedAt
  storeName
  phoneNumber
  officialemail
  zipcode
  streetAddress1
  streetAddress2
  GSTIN
  singleStore
  rentalStore
  channelMarkets
  services
  assetAPI
  mainAPI
}

input StoreSubscriptionFilter {
  and: [StoreSubscriptionFilter!]
  or: [StoreSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

enum StoreTypeEnum {
  DEFAULT
  VENDOR
}

input StoreUpdateFilter {
  and: [StoreUpdateFilter!]
  or: [StoreUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

type StoreZipsAggregateResponse {
  count: StoreZipsCountAggregate
  sum: StoreZipsSumAggregate
  avg: StoreZipsAvgAggregate
  min: StoreZipsMinAggregate
  max: StoreZipsMaxAggregate
}

type StoreZipsAvgAggregate {
  code: Float
}

type StoreZipsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  slug: Int
  code: Int
}

type StoreZipsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

type StoreZipsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

type StoreZipsSumAggregate {
  code: Float
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

type Subscription {
  deletedOneAsset(input: DeleteOneAssetSubscriptionFilterInput): AssetDeleteResponse!
  deletedManyAssets: DeleteManyResponse!
  updatedOneAsset(input: UpdateOneAssetSubscriptionFilterInput): Asset!
  updatedManyAssets: UpdateManyResponse!
  createdAsset(input: CreateAssetSubscriptionFilterInput): Asset!
  deletedOneRole(input: DeleteOneRoleSubscriptionFilterInput): RoleDeleteResponse!
  deletedManyRoles: DeleteManyResponse!
  updatedOneRole(input: UpdateOneRoleSubscriptionFilterInput): Role!
  updatedManyRoles: UpdateManyResponse!
  createdRole(input: CreateRoleSubscriptionFilterInput): Role!
  deletedOneCollection(input: DeleteOneCollectionSubscriptionFilterInput): CollectionDeleteResponse!
  deletedManyCollections: DeleteManyResponse!
  updatedOneCollection(input: UpdateOneCollectionSubscriptionFilterInput): Collection!
  updatedManyCollections: UpdateManyResponse!
  createdCollection(input: CreateCollectionSubscriptionFilterInput): Collection!
  deletedOneChannel(input: DeleteOneChannelSubscriptionFilterInput): ChannelDeleteResponse!
  deletedManyChannels: DeleteManyResponse!
  updatedOneChannel(input: UpdateOneChannelSubscriptionFilterInput): Channel!
  updatedManyChannels: UpdateManyResponse!
  createdChannel(input: CreateChannelSubscriptionFilterInput): Channel!
  deletedOneStore(input: DeleteOneStoreSubscriptionFilterInput): StoreDeleteResponse!
  deletedManyStores: DeleteManyResponse!
  updatedOneStore(input: UpdateOneStoreSubscriptionFilterInput): Store!
  updatedManyStores: UpdateManyResponse!
  createdStore(input: CreateStoreSubscriptionFilterInput): Store!
  deletedOneTaxCategory(input: DeleteOneTaxCategorySubscriptionFilterInput): TaxCategoryDeleteResponse!
  deletedManyTaxCategories: DeleteManyResponse!
  updatedOneTaxCategory(input: UpdateOneTaxCategorySubscriptionFilterInput): TaxCategory!
  updatedManyTaxCategories: UpdateManyResponse!
  createdTaxCategory(input: CreateTaxCategorySubscriptionFilterInput): TaxCategory!
  deletedOneTaxRate(input: DeleteOneTaxRateSubscriptionFilterInput): TaxRateDeleteResponse!
  deletedManyTaxRates: DeleteManyResponse!
  updatedOneTaxRate(input: UpdateOneTaxRateSubscriptionFilterInput): TaxRate!
  updatedManyTaxRates: UpdateManyResponse!
  createdTaxRate(input: CreateTaxRateSubscriptionFilterInput): TaxRate!
  deletedOneUser(input: DeleteOneUserSubscriptionFilterInput): UserDeleteResponse!
  deletedManyUsers: DeleteManyResponse!
  updatedOneUser(input: UpdateOneUserSubscriptionFilterInput): User!
  updatedManyUsers: UpdateManyResponse!
  createdUser(input: CreateUserSubscriptionFilterInput): User!
  deletedOneVendor(input: DeleteOneVendorSubscriptionFilterInput): VendorDeleteResponse!
  deletedManyVendors: DeleteManyResponse!
  updatedOneVendor(input: UpdateOneVendorSubscriptionFilterInput): Vendor!
  updatedManyVendors: UpdateManyResponse!
  createdVendor(input: CreateVendorSubscriptionFilterInput): Vendor!
  deletedOneZone(input: DeleteOneZoneSubscriptionFilterInput): ZoneDeleteResponse!
  deletedManyZones: DeleteManyResponse!
  updatedOneZone(input: UpdateOneZoneSubscriptionFilterInput): Zone!
  updatedManyZones: UpdateManyResponse!
  createdZone(input: CreateZoneSubscriptionFilterInput): Zone!
  deletedOneCountry(input: DeleteOneCountrySubscriptionFilterInput): CountryDeleteResponse!
  deletedManyCountries: DeleteManyResponse!
  updatedOneCountry(input: UpdateOneCountrySubscriptionFilterInput): Country!
  updatedManyCountries: UpdateManyResponse!
  createdCountry(input: CreateCountrySubscriptionFilterInput): Country!
  deletedOneSeo(input: DeleteOneSeoSubscriptionFilterInput): SeoDeleteResponse!
  deletedManySeos: DeleteManyResponse!
  updatedOneSeo(input: UpdateOneSeoSubscriptionFilterInput): Seo!
  updatedManySeos: UpdateManyResponse!
  createdSeo(input: CreateSeoSubscriptionFilterInput): Seo!
  deletedOneFacet(input: DeleteOneFacetSubscriptionFilterInput): FacetDeleteResponse!
  deletedManyFacets: DeleteManyResponse!
  updatedOneFacet(input: UpdateOneFacetSubscriptionFilterInput): Facet!
  updatedManyFacets: UpdateManyResponse!
  createdFacet(input: CreateFacetSubscriptionFilterInput): Facet!
  deletedOneFacetValue(input: DeleteOneFacetValueSubscriptionFilterInput): FacetValueDeleteResponse!
  deletedManyFacetValues: DeleteManyResponse!
  updatedOneFacetValue(input: UpdateOneFacetValueSubscriptionFilterInput): FacetValue!
  updatedManyFacetValues: UpdateManyResponse!
  createdFacetValue(input: CreateFacetValueSubscriptionFilterInput): FacetValue!
  deletedOneProduct(input: DeleteOneProductSubscriptionFilterInput): ProductDeleteResponse!
  deletedManyProducts: DeleteManyResponse!
  updatedOneProduct(input: UpdateOneProductSubscriptionFilterInput): Product!
  updatedManyProducts: UpdateManyResponse!
  createdProduct(input: CreateProductSubscriptionFilterInput): Product!
  deletedOneProductVariant(input: DeleteOneProductVariantSubscriptionFilterInput): ProductVariantDeleteResponse!
  deletedManyProductVariants: DeleteManyResponse!
  updatedOneProductVariant(input: UpdateOneProductVariantSubscriptionFilterInput): ProductVariant!
  updatedManyProductVariants: UpdateManyResponse!
  createdProductVariant(input: CreateProductVariantSubscriptionFilterInput): ProductVariant!
  deletedOneProductOption(input: DeleteOneProductOptionSubscriptionFilterInput): ProductOptionDeleteResponse!
  deletedManyProductOptions: DeleteManyResponse!
  updatedOneProductOption(input: UpdateOneProductOptionSubscriptionFilterInput): ProductOption!
  updatedManyProductOptions: UpdateManyResponse!
  createdProductOption(input: CreateProductOptionSubscriptionFilterInput): ProductOption!
  deletedOneProductOptionGroup(input: DeleteOneProductOptionGroupSubscriptionFilterInput): ProductOptionGroupDeleteResponse!
  deletedManyProductOptionGroups: DeleteManyResponse!
  updatedOneProductOptionGroup(input: UpdateOneProductOptionGroupSubscriptionFilterInput): ProductOptionGroup!
  updatedManyProductOptionGroups: UpdateManyResponse!
  createdProductOptionGroup(input: CreateProductOptionGroupSubscriptionFilterInput): ProductOptionGroup!
  deletedOneProductVariantPrice(input: DeleteOneProductVariantPriceSubscriptionFilterInput): ProductVariantPriceDeleteResponse!
  deletedManyProductVariantPrices: DeleteManyResponse!
  updatedOneProductVariantPrice(input: UpdateOneProductVariantPriceSubscriptionFilterInput): ProductVariantPrice!
  updatedManyProductVariantPrices: UpdateManyResponse!
  createdProductVariantPrice(input: CreateProductVariantPriceSubscriptionFilterInput): ProductVariantPrice!
  deletedOneProductVariantAsset(input: DeleteOneProductVariantAssetSubscriptionFilterInput): ProductVariantAssetDeleteResponse!
  deletedManyProductVariantAssets: DeleteManyResponse!
  updatedOneProductVariantAsset(input: UpdateOneProductVariantAssetSubscriptionFilterInput): ProductVariantAsset!
  updatedManyProductVariantAssets: UpdateManyResponse!
  createdProductVariantAsset(input: CreateProductVariantAssetSubscriptionFilterInput): ProductVariantAsset!
  deletedOneProductAsset(input: DeleteOneProductAssetSubscriptionFilterInput): ProductAssetDeleteResponse!
  deletedManyProductAssets: DeleteManyResponse!
  updatedOneProductAsset(input: UpdateOneProductAssetSubscriptionFilterInput): ProductAsset!
  updatedManyProductAssets: UpdateManyResponse!
  createdProductAsset(input: CreateProductAssetSubscriptionFilterInput): ProductAsset!
  deletedOneVendorPlans(input: DeleteOneVendorPlansSubscriptionFilterInput): VendorPlansDeleteResponse!
  deletedManyVendorPlans: DeleteManyResponse!
  updatedOneVendorPlans(input: UpdateOneVendorPlansSubscriptionFilterInput): VendorPlans!
  updatedManyVendorPlans: UpdateManyResponse!
  createdVendorPlans(input: CreateVendorPlansSubscriptionFilterInput): VendorPlans!
  deletedOneVendorLicense(input: DeleteOneVendorLicenseSubscriptionFilterInput): VendorLicenseDeleteResponse!
  deletedManyVendorLicenses: DeleteManyResponse!
  updatedOneVendorLicense(input: UpdateOneVendorLicenseSubscriptionFilterInput): VendorLicense!
  updatedManyVendorLicenses: UpdateManyResponse!
  createdVendorLicense(input: CreateVendorLicenseSubscriptionFilterInput): VendorLicense!
  deletedOneStockKeeping(input: DeleteOneStockKeepingSubscriptionFilterInput): StockKeepingDeleteResponse!
  deletedManyStockKeepings: DeleteManyResponse!
  updatedOneStockKeeping(input: UpdateOneStockKeepingSubscriptionFilterInput): StockKeeping!
  updatedManyStockKeepings: UpdateManyResponse!
  createdStockKeeping(input: CreateStockKeepingSubscriptionFilterInput): StockKeeping!
  deletedOneSale(input: DeleteOneSaleSubscriptionFilterInput): SaleDeleteResponse!
  deletedManySales: DeleteManyResponse!
  updatedOneSale(input: UpdateOneSaleSubscriptionFilterInput): Sale!
  updatedManySales: UpdateManyResponse!
  createdSale(input: CreateSaleSubscriptionFilterInput): Sale!
  deletedOneStockMovement(input: DeleteOneStockMovementSubscriptionFilterInput): StockMovementDeleteResponse!
  deletedManyStockMovements: DeleteManyResponse!
  updatedOneStockMovement(input: UpdateOneStockMovementSubscriptionFilterInput): StockMovement!
  updatedManyStockMovements: UpdateManyResponse!
  createdStockMovement(input: CreateStockMovementSubscriptionFilterInput): StockMovement!
  deletedOneCancellation(input: DeleteOneCancellationSubscriptionFilterInput): CancellationDeleteResponse!
  deletedManyCancellations: DeleteManyResponse!
  updatedOneCancellation(input: UpdateOneCancellationSubscriptionFilterInput): Cancellation!
  updatedManyCancellations: UpdateManyResponse!
  createdCancellation(input: CreateCancellationSubscriptionFilterInput): Cancellation!
  deletedOneOrder(input: DeleteOneOrderSubscriptionFilterInput): OrderDeleteResponse!
  deletedManyOrders: DeleteManyResponse!
  updatedOneOrder(input: UpdateOneOrderSubscriptionFilterInput): Order!
  updatedManyOrders: UpdateManyResponse!
  createdOrder(input: CreateOrderSubscriptionFilterInput): Order!
  deletedOneZip(input: DeleteOneZipSubscriptionFilterInput): ZipDeleteResponse!
  deletedManyZips: DeleteManyResponse!
  updatedOneZip(input: UpdateOneZipSubscriptionFilterInput): Zip!
  updatedManyZips: UpdateManyResponse!
  createdZip(input: CreateZipSubscriptionFilterInput): Zip!
  deletedOneMenu(input: DeleteOneMenuSubscriptionFilterInput): MenuDeleteResponse!
  deletedManyMenus: DeleteManyResponse!
  updatedOneMenu(input: UpdateOneMenuSubscriptionFilterInput): Menu!
  updatedManyMenus: UpdateManyResponse!
  createdMenu(input: CreateMenuSubscriptionFilterInput): Menu!
  deletedOnePage(input: DeleteOnePageSubscriptionFilterInput): PageDeleteResponse!
  deletedManyPages: DeleteManyResponse!
  updatedOnePage(input: UpdateOnePageSubscriptionFilterInput): Page!
  updatedManyPages: UpdateManyResponse!
  createdPage(input: CreatePageSubscriptionFilterInput): Page!
  deletedOneAddress(input: DeleteOneAddressSubscriptionFilterInput): AddressDeleteResponse!
  deletedManyAddresses: DeleteManyResponse!
  updatedOneAddress(input: UpdateOneAddressSubscriptionFilterInput): Address!
  updatedManyAddresses: UpdateManyResponse!
  createdAddress(input: CreateAddressSubscriptionFilterInput): Address!
  deletedOneSettlements(input: DeleteOneSettlementsSubscriptionFilterInput): SettlementsDeleteResponse!
  deletedManySettlements: DeleteManyResponse!
  updatedOneSettlements(input: UpdateOneSettlementsSubscriptionFilterInput): Settlements!
  updatedManySettlements: UpdateManyResponse!
  createdSettlements(input: CreateSettlementsSubscriptionFilterInput): Settlements!
  deletedOneOrderLine(input: DeleteOneOrderLineSubscriptionFilterInput): OrderLineDeleteResponse!
  deletedManyOrderLines: DeleteManyResponse!
  updatedOneOrderLine(input: UpdateOneOrderLineSubscriptionFilterInput): OrderLine!
  updatedManyOrderLines: UpdateManyResponse!
  createdOrderLine(input: CreateOrderLineSubscriptionFilterInput): OrderLine!
  deletedOneOrderItem(input: DeleteOneOrderItemSubscriptionFilterInput): OrderItemDeleteResponse!
  deletedManyOrderItems: DeleteManyResponse!
  updatedOneOrderItem(input: UpdateOneOrderItemSubscriptionFilterInput): OrderItem!
  updatedManyOrderItems: UpdateManyResponse!
  createdOrderItem(input: CreateOrderItemSubscriptionFilterInput): OrderItem!
  deletedOnePromotionVariantPrice(input: DeleteOnePromotionVariantPriceSubscriptionFilterInput): PromotionVariantPriceDeleteResponse!
  deletedManyPromotionVariantPrices: DeleteManyResponse!
  updatedOnePromotionVariantPrice(input: UpdateOnePromotionVariantPriceSubscriptionFilterInput): PromotionVariantPrice!
  updatedManyPromotionVariantPrices: UpdateManyResponse!
  createdPromotionVariantPrice(input: CreatePromotionVariantPriceSubscriptionFilterInput): PromotionVariantPrice!
  deletedOneCartPriceRules(input: DeleteOneCartPriceRulesSubscriptionFilterInput): CartPriceRulesDeleteResponse!
  deletedManyCartPriceRules: DeleteManyResponse!
  updatedOneCartPriceRules(input: UpdateOneCartPriceRulesSubscriptionFilterInput): CartPriceRules!
  updatedManyCartPriceRules: UpdateManyResponse!
  createdCartPriceRules(input: CreateCartPriceRulesSubscriptionFilterInput): CartPriceRules!
  deletedOneAccount(input: DeleteOneAccountSubscriptionFilterInput): AccountDeleteResponse!
  deletedManyAccounts: DeleteManyResponse!
  updatedOneAccount(input: UpdateOneAccountSubscriptionFilterInput): Account!
  updatedManyAccounts: UpdateManyResponse!
  createdAccount(input: CreateAccountSubscriptionFilterInput): Account!
  deletedOneDelivery(input: DeleteOneDeliverySubscriptionFilterInput): DeliveryDeleteResponse!
  deletedManyDeliveries: DeleteManyResponse!
  updatedOneDelivery(input: UpdateOneDeliverySubscriptionFilterInput): Delivery!
  updatedManyDeliveries: UpdateManyResponse!
  createdDelivery(input: CreateDeliverySubscriptionFilterInput): Delivery!
  deletedOneStockBackLog(input: DeleteOneStockBackLogSubscriptionFilterInput): StockBackLogDeleteResponse!
  deletedManyStockBackLogs: DeleteManyResponse!
  updatedOneStockBackLog(input: UpdateOneStockBackLogSubscriptionFilterInput): StockBackLog!
  updatedManyStockBackLogs: UpdateManyResponse!
  createdStockBackLog(input: CreateStockBackLogSubscriptionFilterInput): StockBackLog!
  deletedOneInvoice(input: DeleteOneInvoiceSubscriptionFilterInput): InvoiceDeleteResponse!
  deletedManyInvoices: DeleteManyResponse!
  updatedOneInvoice(input: UpdateOneInvoiceSubscriptionFilterInput): Invoice!
  updatedManyInvoices: UpdateManyResponse!
  createdInvoice(input: CreateInvoiceSubscriptionFilterInput): Invoice!
  deletedOneRefund(input: DeleteOneRefundSubscriptionFilterInput): RefundDeleteResponse!
  deletedManyRefunds: DeleteManyResponse!
  updatedOneRefund(input: UpdateOneRefundSubscriptionFilterInput): Refund!
  updatedManyRefunds: UpdateManyResponse!
  createdRefund(input: CreateRefundSubscriptionFilterInput): Refund!
  deletedOnePayment(input: DeleteOnePaymentSubscriptionFilterInput): PaymentDeleteResponse!
  deletedManyPayments: DeleteManyResponse!
  updatedOnePayment(input: UpdateOnePaymentSubscriptionFilterInput): Payment!
  updatedManyPayments: UpdateManyResponse!
  createdPayment(input: CreatePaymentSubscriptionFilterInput): Payment!
  deletedOneViewCode(input: DeleteOneViewCodeSubscriptionFilterInput): ViewCodeDeleteResponse!
  deletedManyViewCodes: DeleteManyResponse!
  updatedOneViewCode(input: UpdateOneViewCodeSubscriptionFilterInput): ViewCode!
  updatedManyViewCodes: UpdateManyResponse!
  createdViewCode(input: CreateViewCodeSubscriptionFilterInput): ViewCode!
  deletedOneHsn(input: DeleteOneHsnSubscriptionFilterInput): HsnDeleteResponse!
  deletedManyHsns: DeleteManyResponse!
  updatedOneHsn(input: UpdateOneHsnSubscriptionFilterInput): Hsn!
  updatedManyHsns: UpdateManyResponse!
  createdHsn(input: CreateHsnSubscriptionFilterInput): Hsn!
  deletedOneServiceable(input: DeleteOneServiceableSubscriptionFilterInput): ServiceableDeleteResponse!
  deletedManyServiceables: DeleteManyResponse!
  updatedOneServiceable(input: UpdateOneServiceableSubscriptionFilterInput): Serviceable!
  updatedManyServiceables: UpdateManyResponse!
  createdServiceable(input: CreateServiceableSubscriptionFilterInput): Serviceable!
}

type TaxCategory {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  rates(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxRateFilter = {}

    """Specify to sort results."""
    sorting: [TaxRateSort!] = []
  ): [TaxRate!]!
  ratesAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxRateAggregateFilter
  ): TaxCategoryRatesAggregateResponse!
}

input TaxCategoryAggregateFilter {
  and: [TaxCategoryAggregateFilter!]
  or: [TaxCategoryAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type TaxCategoryAggregateResponse {
  count: TaxCategoryCountAggregate
  min: TaxCategoryMinAggregate
  max: TaxCategoryMaxAggregate
}

type TaxCategoryCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
}

input TaxCategoryDeleteFilter {
  and: [TaxCategoryDeleteFilter!]
  or: [TaxCategoryDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type TaxCategoryDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input TaxCategoryFilter {
  and: [TaxCategoryFilter!]
  or: [TaxCategoryFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type TaxCategoryMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

type TaxCategoryMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

type TaxCategoryRatesAggregateResponse {
  count: TaxCategoryRatesCountAggregate
  sum: TaxCategoryRatesSumAggregate
  avg: TaxCategoryRatesAvgAggregate
  min: TaxCategoryRatesMinAggregate
  max: TaxCategoryRatesMaxAggregate
}

type TaxCategoryRatesAvgAggregate {
  value: Float
}

type TaxCategoryRatesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  value: Int
  enabled: Int
}

type TaxCategoryRatesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

type TaxCategoryRatesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

type TaxCategoryRatesSumAggregate {
  value: Float
}

input TaxCategorySort {
  field: TaxCategorySortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxCategorySortFields {
  id
  createdAt
  updatedAt
  name
}

input TaxCategorySubscriptionFilter {
  and: [TaxCategorySubscriptionFilter!]
  or: [TaxCategorySubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

input TaxCategoryUpdateFilter {
  and: [TaxCategoryUpdateFilter!]
  or: [TaxCategoryUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type TaxRate {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  value: Float!
  enabled: Boolean!
  variants(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ProductVariantPriceFilter = {}

    """Specify to sort results."""
    sorting: [ProductVariantPriceSort!] = []
  ): [ProductVariantPrice!]!
  zone: Zone!
  category: TaxCategory!
  variantsAggregate(
    """Filter to find records to aggregate on"""
    filter: ProductVariantPriceAggregateFilter
  ): TaxRateVariantsAggregateResponse!
}

input TaxRateAggregateFilter {
  and: [TaxRateAggregateFilter!]
  or: [TaxRateAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  value: NumberFieldComparison
  enabled: BooleanFieldComparison
}

type TaxRateAggregateResponse {
  count: TaxRateCountAggregate
  sum: TaxRateSumAggregate
  avg: TaxRateAvgAggregate
  min: TaxRateMinAggregate
  max: TaxRateMaxAggregate
}

type TaxRateAvgAggregate {
  value: Float
}

type TaxRateCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  value: Int
  enabled: Int
}

input TaxRateDeleteFilter {
  and: [TaxRateDeleteFilter!]
  or: [TaxRateDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  value: NumberFieldComparison
  enabled: BooleanFieldComparison
}

type TaxRateDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
  enabled: Boolean
}

input TaxRateFilter {
  and: [TaxRateFilter!]
  or: [TaxRateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  value: NumberFieldComparison
  enabled: BooleanFieldComparison
}

type TaxRateMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

type TaxRateMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

input TaxRateSort {
  field: TaxRateSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum TaxRateSortFields {
  id
  createdAt
  updatedAt
  name
  value
  enabled
}

input TaxRateSubscriptionFilter {
  and: [TaxRateSubscriptionFilter!]
  or: [TaxRateSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  value: NumberFieldComparison
  enabled: BooleanFieldComparison
}

type TaxRateSumAggregate {
  value: Float
}

input TaxRateUpdateFilter {
  and: [TaxRateUpdateFilter!]
  or: [TaxRateUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  value: NumberFieldComparison
  enabled: BooleanFieldComparison
}

type TaxRateVariantsAggregateResponse {
  count: TaxRateVariantsCountAggregate
  sum: TaxRateVariantsSumAggregate
  avg: TaxRateVariantsAvgAggregate
  min: TaxRateVariantsMinAggregate
  max: TaxRateVariantsMaxAggregate
}

type TaxRateVariantsAvgAggregate {
  price: Float
}

type TaxRateVariantsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  price: Int
  taxIncluded: Int
}

type TaxRateVariantsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type TaxRateVariantsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
}

type TaxRateVariantsSumAggregate {
  price: Float
}

input UpdateAddress {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  defaultShippingAddress: Boolean
  defaultBillingAddress: Boolean
  addressType: AddressType
}

input UpdateCancellation {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input UpdateCartPriceRules {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
}

input UpdateChannel {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  code: String
  token: String
  defaultLanguageCode: LanguageCode
  currencyCode: CurrencyCode
  pricesIncludeTax: Boolean
}

input UpdateCollection {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  isRoot: Boolean
  inMenu: Boolean
  position: Float
  isPrivate: Boolean
  name: String
  description: String
}

input UpdateCountry {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
  enabled: Boolean
}

input UpdateFacet {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  isPrivate: Boolean
  code: String
}

input UpdateFacetValue {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
}

input UpdateHsn {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  value: Float
}

input UpdateManyAddressesInput {
  """Filter used to find fields to update"""
  filter: AddressUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateAddress!
}

input UpdateManyCancellationsInput {
  """Filter used to find fields to update"""
  filter: CancellationUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateCancellation!
}

input UpdateManyCartPriceRulesInput {
  """Filter used to find fields to update"""
  filter: CartPriceRulesUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateCartPriceRules!
}

input UpdateManyChannelsInput {
  """Filter used to find fields to update"""
  filter: ChannelUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateChannel!
}

input UpdateManyCollectionsInput {
  """Filter used to find fields to update"""
  filter: CollectionUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateCollection!
}

input UpdateManyCountriesInput {
  """Filter used to find fields to update"""
  filter: CountryUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateCountry!
}

input UpdateManyFacetsInput {
  """Filter used to find fields to update"""
  filter: FacetUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateFacet!
}

input UpdateManyFacetValuesInput {
  """Filter used to find fields to update"""
  filter: FacetValueUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateFacetValue!
}

input UpdateManyHsnsInput {
  """Filter used to find fields to update"""
  filter: HsnUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateHsn!
}

input UpdateManyMenusInput {
  """Filter used to find fields to update"""
  filter: MenuUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateMenu!
}

input UpdateManyOrderLinesInput {
  """Filter used to find fields to update"""
  filter: OrderLineUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateOrderLine!
}

input UpdateManyPagesInput {
  """Filter used to find fields to update"""
  filter: PageUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdatePage!
}

input UpdateManyProductAssetsInput {
  """Filter used to find fields to update"""
  filter: ProductAssetUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProductAsset!
}

input UpdateManyProductOptionGroupsInput {
  """Filter used to find fields to update"""
  filter: ProductOptionGroupUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProductOptionGroup!
}

input UpdateManyProductOptionsInput {
  """Filter used to find fields to update"""
  filter: ProductOptionUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProductOption!
}

input UpdateManyProductsInput {
  """Filter used to find fields to update"""
  filter: ProductUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProduct!
}

input UpdateManyProductVariantPricesInput {
  """Filter used to find fields to update"""
  filter: ProductVariantPriceUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProductVariantPrice!
}

input UpdateManyPromotionVariantPricesInput {
  """Filter used to find fields to update"""
  filter: PromotionVariantPriceUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdatePromotionVariantPrice!
}

input UpdateManyRefundsInput {
  """Filter used to find fields to update"""
  filter: RefundUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateRefund!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateManySalesInput {
  """Filter used to find fields to update"""
  filter: SaleUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateSale!
}

input UpdateManySeosInput {
  """Filter used to find fields to update"""
  filter: SeoUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateSeo!
}

input UpdateManyServiceablesInput {
  """Filter used to find fields to update"""
  filter: ServiceableUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateServiceable!
}

input UpdateManyStockBackLogsInput {
  """Filter used to find fields to update"""
  filter: StockBackLogUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateStockBackLog!
}

input UpdateManyStockKeepingsInput {
  """Filter used to find fields to update"""
  filter: StockKeepingUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateStockKeeping!
}

input UpdateManyStockMovementsInput {
  """Filter used to find fields to update"""
  filter: StockMovementUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateStockMovement!
}

input UpdateManyStoresInput {
  """Filter used to find fields to update"""
  filter: StoreUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateStore!
}

input UpdateManyTaxCategoriesInput {
  """Filter used to find fields to update"""
  filter: TaxCategoryUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateTaxCategory!
}

input UpdateManyTaxRatesInput {
  """Filter used to find fields to update"""
  filter: TaxRateUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateTaxRate!
}

input UpdateManyZipsInput {
  """Filter used to find fields to update"""
  filter: ZipUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateZip!
}

input UpdateManyZonesInput {
  """Filter used to find fields to update"""
  filter: ZoneUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateZone!
}

input UpdateMenu {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  title: String
  targetId: String
  target: MenuBuilderTypes
}

input UpdateOneAccountSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AccountSubscriptionFilter!
}

input UpdateOneAddressInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateAddress!
}

input UpdateOneAddressSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AddressSubscriptionFilter!
}

input UpdateOneAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: AssetSubscriptionFilter!
}

input UpdateOneCancellationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCancellation!
}

input UpdateOneCancellationSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CancellationSubscriptionFilter!
}

input UpdateOneCartPriceRulesInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCartPriceRules!
}

input UpdateOneCartPriceRulesSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CartPriceRulesSubscriptionFilter!
}

input UpdateOneChannelInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateChannel!
}

input UpdateOneChannelSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ChannelSubscriptionFilter!
}

input UpdateOneCollectionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCollection!
}

input UpdateOneCollectionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CollectionSubscriptionFilter!
}

input UpdateOneCountryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCountry!
}

input UpdateOneCountrySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: CountrySubscriptionFilter!
}

input UpdateOneDeliverySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: DeliverySubscriptionFilter!
}

input UpdateOneFacetInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFacet!
}

input UpdateOneFacetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetSubscriptionFilter!
}

input UpdateOneFacetValueInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFacetValue!
}

input UpdateOneFacetValueSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FacetValueSubscriptionFilter!
}

input UpdateOneHsnInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateHsn!
}

input UpdateOneHsnSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: HsnSubscriptionFilter!
}

input UpdateOneInvoiceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: InvoiceSubscriptionFilter!
}

input UpdateOneMenuInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateMenu!
}

input UpdateOneMenuSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: MenuSubscriptionFilter!
}

input UpdateOneOrderItemSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderItemSubscriptionFilter!
}

input UpdateOneOrderLineInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateOrderLine!
}

input UpdateOneOrderLineSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderLineSubscriptionFilter!
}

input UpdateOneOrderSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: OrderSubscriptionFilter!
}

input UpdateOnePageInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePage!
}

input UpdateOnePageSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PageSubscriptionFilter!
}

input UpdateOnePaymentSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PaymentSubscriptionFilter!
}

input UpdateOneProductAssetInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProductAsset!
}

input UpdateOneProductAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductAssetSubscriptionFilter!
}

input UpdateOneProductInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProduct!
}

input UpdateOneProductOptionGroupInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProductOptionGroup!
}

input UpdateOneProductOptionGroupSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionGroupSubscriptionFilter!
}

input UpdateOneProductOptionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProductOption!
}

input UpdateOneProductOptionSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductOptionSubscriptionFilter!
}

input UpdateOneProductSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductSubscriptionFilter!
}

input UpdateOneProductVariantAssetSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantAssetSubscriptionFilter!
}

input UpdateOneProductVariantPriceInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProductVariantPrice!
}

input UpdateOneProductVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantPriceSubscriptionFilter!
}

input UpdateOneProductVariantSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ProductVariantSubscriptionFilter!
}

input UpdateOnePromotionVariantPriceInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePromotionVariantPrice!
}

input UpdateOnePromotionVariantPriceSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: PromotionVariantPriceSubscriptionFilter!
}

input UpdateOneRefundInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateRefund!
}

input UpdateOneRefundSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RefundSubscriptionFilter!
}

input UpdateOneRoleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: RoleSubscriptionFilter!
}

input UpdateOneSaleInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSale!
}

input UpdateOneSaleSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SaleSubscriptionFilter!
}

input UpdateOneSeoInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSeo!
}

input UpdateOneSeoSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SeoSubscriptionFilter!
}

input UpdateOneServiceableInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateServiceable!
}

input UpdateOneServiceableSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ServiceableSubscriptionFilter!
}

input UpdateOneSettlementsSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: SettlementsSubscriptionFilter!
}

input UpdateOneStockBackLogInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateStockBackLog!
}

input UpdateOneStockBackLogSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockBackLogSubscriptionFilter!
}

input UpdateOneStockKeepingInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateStockKeeping!
}

input UpdateOneStockKeepingSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockKeepingSubscriptionFilter!
}

input UpdateOneStockMovementInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateStockMovement!
}

input UpdateOneStockMovementSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StockMovementSubscriptionFilter!
}

input UpdateOneStoreInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateStore!
}

input UpdateOneStoreSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: StoreSubscriptionFilter!
}

input UpdateOneTaxCategoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateTaxCategory!
}

input UpdateOneTaxCategorySubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxCategorySubscriptionFilter!
}

input UpdateOneTaxRateInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateTaxRate!
}

input UpdateOneTaxRateSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: TaxRateSubscriptionFilter!
}

input UpdateOneUserSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: UserSubscriptionFilter!
}

input UpdateOneVendorLicenseSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorLicenseSubscriptionFilter!
}

input UpdateOneVendorPlansSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorPlansSubscriptionFilter!
}

input UpdateOneVendorSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: VendorSubscriptionFilter!
}

input UpdateOneViewCodeSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ViewCodeSubscriptionFilter!
}

input UpdateOneZipInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateZip!
}

input UpdateOneZipSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZipSubscriptionFilter!
}

input UpdateOneZoneInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateZone!
}

input UpdateOneZoneSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: ZoneSubscriptionFilter!
}

input UpdateOrderLine {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceField: JSON
  stage: OrderStageType
}

input UpdatePage {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  title: String
  targetId: String
  single: JSON
  list: [String!]
  pageType: PageType
  pageCategory: PageCategory
}

input UpdateProduct {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  productName: String
  slug: String
  description: String
  viewcode: [String!]
}

input UpdateProductAsset {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
}

input UpdateProductOption {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input UpdateProductOptionGroup {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  code: String
}

input UpdateProductVariantPrice {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  price: Float
  taxIncluded: Boolean
}

input UpdatePromotionVariantPrice {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  priceType: PricePromoType
  value: Float
  forever: Boolean
  startsAt: DateTime
  endsAt: DateTime
  enabled: Boolean
}

input UpdateRefund {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  reason: String
  destination: String
  transactionId: String
  stage: RefundEnum
}

input UpdateSale {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input UpdateSeo {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  urlKey: String
  metatitle: String
  metakeywords: [String!]
  metadesc: String
}

input UpdateServiceable {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  type: ServiceableTypes
  mode: ServiceableOrderTypes
}

input UpdateStockBackLog {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input UpdateStockKeeping {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
  available_quantity: Float
  threshold: Float
  multiple: Boolean
  backorder: Boolean
  stockstatus: Boolean
  sku: String
  type: StockKeepingType
}

input UpdateStockMovement {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  quantity: Float
}

input UpdateStore {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  singleStore: Boolean
  rentalStore: Boolean
  channelMarkets: Boolean
  services: Boolean
  assetAPI: String
  mainAPI: String
  type: StoreTypeEnum
}

input UpdateTaxCategory {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input UpdateTaxRate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
  enabled: Boolean
}

input UpdateZip {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

input UpdateZone {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  verified: Boolean!
  verificationToken: String
  passwordResetToken: String
  identifierChangeToken: String
  pendingIdentifier: String
  lastLogin: DateTime
  firstName: String
  lastName: String
  phoneNumber: String!
  administrator: Administrator
  vendor: Vendor
  delivery: Delivery
  cart: Cart
  view: [View!]!
  reviews: [Review!]!
  address: [Address!]
  order: [Order!]
  reset: [ResetCode!]
  orders(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: OrderFilter = {}

    """Specify to sort results."""
    sorting: [OrderSort!] = []
  ): [Order!]
  addresses(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: AddressFilter = {}

    """Specify to sort results."""
    sorting: [AddressSort!] = []
  ): [Address!]
  ordersAggregate(
    """Filter to find records to aggregate on"""
    filter: OrderAggregateFilter
  ): UserOrdersAggregateResponse!
  addressesAggregate(
    """Filter to find records to aggregate on"""
    filter: AddressAggregateFilter
  ): UserAddressesAggregateResponse!
}

type UserAddressesAggregateResponse {
  count: UserAddressesCountAggregate
  min: UserAddressesMinAggregate
  max: UserAddressesMaxAggregate
}

type UserAddressesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  fullName: Int
  addressLine: Int
  city: Int
  state: Int
  landmark: Int
  postalCode: Int
  phoneNumber: Int
  alternatePhoneNumber: Int
  defaultShippingAddress: Int
  defaultBillingAddress: Int
  addressType: Int
}

type UserAddressesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  addressType: AddressType
}

type UserAddressesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  fullName: String
  addressLine: String
  city: String
  state: String
  landmark: String
  postalCode: String
  phoneNumber: String
  alternatePhoneNumber: String
  addressType: AddressType
}

input UserAggregateFilter {
  and: [UserAggregateFilter!]
  or: [UserAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  email: StringFieldComparison
  verified: BooleanFieldComparison
  verificationToken: StringFieldComparison
  passwordResetToken: StringFieldComparison
  identifierChangeToken: StringFieldComparison
  pendingIdentifier: StringFieldComparison
  lastLogin: DateFieldComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  phoneNumber: StringFieldComparison
}

type UserAggregateResponse {
  count: UserCountAggregate
  min: UserMinAggregate
  max: UserMaxAggregate
}

type UserCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  email: Int
  verified: Int
  verificationToken: Int
  passwordResetToken: Int
  identifierChangeToken: Int
  pendingIdentifier: Int
  lastLogin: Int
  firstName: Int
  lastName: Int
  phoneNumber: Int
}

input UserDeleteFilter {
  and: [UserDeleteFilter!]
  or: [UserDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  email: StringFieldComparison
  verified: BooleanFieldComparison
  verificationToken: StringFieldComparison
  passwordResetToken: StringFieldComparison
  identifierChangeToken: StringFieldComparison
  pendingIdentifier: StringFieldComparison
  lastLogin: DateFieldComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  phoneNumber: StringFieldComparison
}

type UserDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  email: String
  verified: Boolean
  verificationToken: String
  passwordResetToken: String
  identifierChangeToken: String
  pendingIdentifier: String
  lastLogin: DateTime
  firstName: String
  lastName: String
  phoneNumber: String
  administrator: Administrator
  vendor: Vendor
  delivery: Delivery
  cart: Cart
  view: [View!]
  reviews: [Review!]
  address: [Address!]
  order: [Order!]
  reset: [ResetCode!]
}

input UserFilter {
  and: [UserFilter!]
  or: [UserFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  email: StringFieldComparison
  verified: BooleanFieldComparison
  verificationToken: StringFieldComparison
  passwordResetToken: StringFieldComparison
  identifierChangeToken: StringFieldComparison
  pendingIdentifier: StringFieldComparison
  lastLogin: DateFieldComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  phoneNumber: StringFieldComparison
}

type UserMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  email: String
  verificationToken: String
  passwordResetToken: String
  identifierChangeToken: String
  pendingIdentifier: String
  lastLogin: DateTime
  firstName: String
  lastName: String
  phoneNumber: String
}

type UserMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  email: String
  verificationToken: String
  passwordResetToken: String
  identifierChangeToken: String
  pendingIdentifier: String
  lastLogin: DateTime
  firstName: String
  lastName: String
  phoneNumber: String
}

type UserOrdersAggregateResponse {
  count: UserOrdersCountAggregate
  sum: UserOrdersSumAggregate
  avg: UserOrdersAvgAggregate
  min: UserOrdersMinAggregate
  max: UserOrdersMaxAggregate
}

type UserOrdersAvgAggregate {
  totalPrice: Float
}

type UserOrdersCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  totalPrice: Int
  address: Int
}

type UserOrdersMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  totalPrice: Float
  address: String
}

type UserOrdersMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  totalPrice: Float
  address: String
}

type UserOrdersSumAggregate {
  totalPrice: Float
}

input UserSort {
  field: UserSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum UserSortFields {
  id
  createdAt
  updatedAt
  email
  verified
  verificationToken
  passwordResetToken
  identifierChangeToken
  pendingIdentifier
  lastLogin
  firstName
  lastName
  phoneNumber
}

input UserSubscriptionFilter {
  and: [UserSubscriptionFilter!]
  or: [UserSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  email: StringFieldComparison
  verified: BooleanFieldComparison
  verificationToken: StringFieldComparison
  passwordResetToken: StringFieldComparison
  identifierChangeToken: StringFieldComparison
  pendingIdentifier: StringFieldComparison
  lastLogin: DateFieldComparison
  firstName: StringFieldComparison
  lastName: StringFieldComparison
  phoneNumber: StringFieldComparison
}

type Vendor {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  vendorName: String!
  phoneNumber: String!
  email: String!
  zip: Zip
  zips(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: ZipFilter = {}

    """Specify to sort results."""
    sorting: [ZipSort!] = []
  ): [Zip!]!
  serviceable: Serviceable
  account: Store!
  store: Store!
  license: VendorLicense!
  user: User!
  zipsAggregate(
    """Filter to find records to aggregate on"""
    filter: ZipAggregateFilter
  ): VendorZipsAggregateResponse!
}

input VendorAggregateFilter {
  and: [VendorAggregateFilter!]
  or: [VendorAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  vendorName: StringFieldComparison
  phoneNumber: StringFieldComparison
  email: StringFieldComparison
}

type VendorAggregateResponse {
  count: VendorCountAggregate
  min: VendorMinAggregate
  max: VendorMaxAggregate
}

type VendorCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  vendorName: Int
  phoneNumber: Int
  email: Int
}

type VendorDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
  zip: Zip
}

type VendorDto {
  user: User!
  token: String!
  vendor: Vendor!
}

input VendorFilter {
  and: [VendorFilter!]
  or: [VendorFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  vendorName: StringFieldComparison
  phoneNumber: StringFieldComparison
  email: StringFieldComparison
  zip: VendorFilterZipFilter
}

input VendorFilterZipFilter {
  and: [VendorFilterZipFilter!]
  or: [VendorFilterZipFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type VendorLicense {
  id: ID!
  deletedAt: DateTime!
  tenureStart: DateTime!
  tenureEnd: DateTime!
  plans: VendorPlans!
  vendor: Vendor!
}

input VendorLicenseAggregateFilter {
  and: [VendorLicenseAggregateFilter!]
  or: [VendorLicenseAggregateFilter!]
  id: IDFilterComparison
  deletedAt: DateFieldComparison
  tenureStart: DateFieldComparison
  tenureEnd: DateFieldComparison
}

type VendorLicenseAggregateResponse {
  count: VendorLicenseCountAggregate
  min: VendorLicenseMinAggregate
  max: VendorLicenseMaxAggregate
}

type VendorLicenseCountAggregate {
  id: Int
  deletedAt: Int
  tenureStart: Int
  tenureEnd: Int
}

type VendorLicenseDeleteResponse {
  id: ID
  deletedAt: DateTime
  tenureStart: DateTime
  tenureEnd: DateTime
}

input VendorLicenseFilter {
  and: [VendorLicenseFilter!]
  or: [VendorLicenseFilter!]
  id: IDFilterComparison
  deletedAt: DateFieldComparison
  tenureStart: DateFieldComparison
  tenureEnd: DateFieldComparison
}

type VendorLicenseMaxAggregate {
  id: ID
  deletedAt: DateTime
  tenureStart: DateTime
  tenureEnd: DateTime
}

type VendorLicenseMinAggregate {
  id: ID
  deletedAt: DateTime
  tenureStart: DateTime
  tenureEnd: DateTime
}

input VendorLicenseSort {
  field: VendorLicenseSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum VendorLicenseSortFields {
  id
  deletedAt
  tenureStart
  tenureEnd
}

input VendorLicenseSubscriptionFilter {
  and: [VendorLicenseSubscriptionFilter!]
  or: [VendorLicenseSubscriptionFilter!]
  id: IDFilterComparison
  deletedAt: DateFieldComparison
  tenureStart: DateFieldComparison
  tenureEnd: DateFieldComparison
}

type VendorMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

type VendorMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

enum VendorPlanPrice {
  FLAT
  INDIVIDUALCOLLECTION
  COMMISSION
}

type VendorPlans {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  isActive: Boolean!
  name: String!
  planValue: Float!
  priceStrategy: String!
  tenureStrategy: VendorPlanTenure!
  licences(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorLicenseFilter = {}

    """Specify to sort results."""
    sorting: [VendorLicenseSort!] = []
  ): [VendorLicense!]!
  licencesAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorLicenseAggregateFilter
  ): VendorPlansLicencesAggregateResponse!
}

input VendorPlansAggregateFilter {
  and: [VendorPlansAggregateFilter!]
  or: [VendorPlansAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  planValue: NumberFieldComparison
}

type VendorPlansAggregateResponse {
  count: VendorPlansCountAggregate
  sum: VendorPlansSumAggregate
  avg: VendorPlansAvgAggregate
  min: VendorPlansMinAggregate
  max: VendorPlansMaxAggregate
}

type VendorPlansAvgAggregate {
  planValue: Float
}

type VendorPlansCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  isActive: Int
  name: Int
  planValue: Int
}

type VendorPlansDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  isActive: Boolean
  name: String
  planValue: Float
  priceStrategy: String
  tenureStrategy: VendorPlanTenure
}

input VendorPlansFilter {
  and: [VendorPlansFilter!]
  or: [VendorPlansFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  planValue: NumberFieldComparison
}

type VendorPlansLicencesAggregateResponse {
  count: VendorPlansLicencesCountAggregate
  min: VendorPlansLicencesMinAggregate
  max: VendorPlansLicencesMaxAggregate
}

type VendorPlansLicencesCountAggregate {
  id: Int
  deletedAt: Int
  tenureStart: Int
  tenureEnd: Int
}

type VendorPlansLicencesMaxAggregate {
  id: ID
  deletedAt: DateTime
  tenureStart: DateTime
  tenureEnd: DateTime
}

type VendorPlansLicencesMinAggregate {
  id: ID
  deletedAt: DateTime
  tenureStart: DateTime
  tenureEnd: DateTime
}

type VendorPlansMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  planValue: Float
}

type VendorPlansMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  planValue: Float
}

input VendorPlansSort {
  field: VendorPlansSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum VendorPlansSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  isActive
  name
  planValue
}

input VendorPlansSubscriptionFilter {
  and: [VendorPlansSubscriptionFilter!]
  or: [VendorPlansSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  isActive: BooleanFieldComparison
  name: StringFieldComparison
  planValue: NumberFieldComparison
}

type VendorPlansSumAggregate {
  planValue: Float
}

enum VendorPlanTenure {
  MONTHLY
  HALFYEARLY
  ANNUAL
}

input VendorSort {
  field: VendorSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum VendorSortFields {
  id
  createdAt
  updatedAt
  vendorName
  phoneNumber
  email
}

input VendorSubscriptionFilter {
  and: [VendorSubscriptionFilter!]
  or: [VendorSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  vendorName: StringFieldComparison
  phoneNumber: StringFieldComparison
  email: StringFieldComparison
}

type VendorZipsAggregateResponse {
  count: VendorZipsCountAggregate
  sum: VendorZipsSumAggregate
  avg: VendorZipsAvgAggregate
  min: VendorZipsMinAggregate
  max: VendorZipsMaxAggregate
}

type VendorZipsAvgAggregate {
  code: Float
}

type VendorZipsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  slug: Int
  code: Int
}

type VendorZipsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

type VendorZipsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

type VendorZipsSumAggregate {
  code: Float
}

type View {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ViewCode {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime!
  name: String!
  value: String!
  description: String!
}

input ViewCodeAggregateFilter {
  and: [ViewCodeAggregateFilter!]
  or: [ViewCodeAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  value: StringFieldComparison
  description: StringFieldComparison
}

type ViewCodeAggregateResponse {
  count: ViewCodeCountAggregate
  min: ViewCodeMinAggregate
  max: ViewCodeMaxAggregate
}

type ViewCodeCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  name: Int
  value: Int
  description: Int
}

type ViewCodeDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  value: String
  description: String
}

input ViewCodeFilter {
  and: [ViewCodeFilter!]
  or: [ViewCodeFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  value: StringFieldComparison
  description: StringFieldComparison
}

type ViewCodeMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  value: String
  description: String
}

type ViewCodeMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  name: String
  value: String
  description: String
}

input ViewCodeSort {
  field: ViewCodeSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ViewCodeSortFields {
  id
  createdAt
  updatedAt
  deletedAt
  name
  value
  description
}

input ViewCodeSubscriptionFilter {
  and: [ViewCodeSubscriptionFilter!]
  or: [ViewCodeSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  deletedAt: DateFieldComparison
  name: StringFieldComparison
  value: StringFieldComparison
  description: StringFieldComparison
}

type Zip {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  slug: String!
  code: Float!
  stores(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StoreFilter = {}

    """Specify to sort results."""
    sorting: [StoreSort!] = []
  ): [Store!]!
  vendors(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: VendorFilter = {}

    """Specify to sort results."""
    sorting: [VendorSort!] = []
  ): [Vendor!]!
  storesAggregate(
    """Filter to find records to aggregate on"""
    filter: StoreAggregateFilter
  ): ZipStoresAggregateResponse!
  vendorsAggregate(
    """Filter to find records to aggregate on"""
    filter: VendorAggregateFilter
  ): ZipVendorsAggregateResponse!
}

input ZipAggregateFilter {
  and: [ZipAggregateFilter!]
  or: [ZipAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type ZipAggregateResponse {
  count: ZipCountAggregate
  sum: ZipSumAggregate
  avg: ZipAvgAggregate
  min: ZipMinAggregate
  max: ZipMaxAggregate
}

type ZipAvgAggregate {
  code: Float
}

type ZipCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  slug: Int
  code: Int
}

input ZipDeleteFilter {
  and: [ZipDeleteFilter!]
  or: [ZipDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type ZipDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

input ZipFilter {
  and: [ZipFilter!]
  or: [ZipFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
  store: ZipFilterStoreFilter
  vendors: ZipFilterVendorFilter
}

input ZipFilterStoreFilter {
  and: [ZipFilterStoreFilter!]
  or: [ZipFilterStoreFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  storeName: StringFieldComparison
  phoneNumber: StringFieldComparison
  officialemail: StringFieldComparison
  zipcode: StringFieldComparison
  streetAddress1: StringFieldComparison
  streetAddress2: StringFieldComparison
  GSTIN: StringFieldComparison
  singleStore: BooleanFieldComparison
  rentalStore: BooleanFieldComparison
  channelMarkets: BooleanFieldComparison
  services: BooleanFieldComparison
  assetAPI: StringFieldComparison
  mainAPI: StringFieldComparison
}

input ZipFilterVendorFilter {
  and: [ZipFilterVendorFilter!]
  or: [ZipFilterVendorFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  vendorName: StringFieldComparison
  phoneNumber: StringFieldComparison
  email: StringFieldComparison
}

type ZipMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

type ZipMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  slug: String
  code: Float
}

input ZipSort {
  field: ZipSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ZipSortFields {
  id
  createdAt
  updatedAt
  name
  slug
  code
}

type ZipStoresAggregateResponse {
  count: ZipStoresCountAggregate
  min: ZipStoresMinAggregate
  max: ZipStoresMaxAggregate
}

type ZipStoresCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  storeName: Int
  phoneNumber: Int
  officialemail: Int
  zipcode: Int
  streetAddress1: Int
  streetAddress2: Int
  GSTIN: Int
  singleStore: Int
  rentalStore: Int
  channelMarkets: Int
  services: Int
  assetAPI: Int
  mainAPI: Int
}

type ZipStoresMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

type ZipStoresMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

input ZipSubscriptionFilter {
  and: [ZipSubscriptionFilter!]
  or: [ZipSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type ZipSumAggregate {
  code: Float
}

input ZipUpdateFilter {
  and: [ZipUpdateFilter!]
  or: [ZipUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
  slug: StringFieldComparison
  code: NumberFieldComparison
}

type ZipVendorsAggregateResponse {
  count: ZipVendorsCountAggregate
  min: ZipVendorsMinAggregate
  max: ZipVendorsMaxAggregate
}

type ZipVendorsCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  vendorName: Int
  phoneNumber: Int
  email: Int
}

type ZipVendorsMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

type ZipVendorsMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  vendorName: String
  phoneNumber: String
  email: String
}

type Zone {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  members(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: CountryFilter = {}

    """Specify to sort results."""
    sorting: [CountrySort!] = []
  ): [Country!]!
  stores(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: StoreFilter = {}

    """Specify to sort results."""
    sorting: [StoreSort!] = []
  ): [Store!]!
  taxrates(
    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to filter the records returned."""
    filter: TaxRateFilter = {}

    """Specify to sort results."""
    sorting: [TaxRateSort!] = []
  ): [TaxRate!]!
  membersAggregate(
    """Filter to find records to aggregate on"""
    filter: CountryAggregateFilter
  ): ZoneMembersAggregateResponse!
  storesAggregate(
    """Filter to find records to aggregate on"""
    filter: StoreAggregateFilter
  ): ZoneStoresAggregateResponse!
  taxratesAggregate(
    """Filter to find records to aggregate on"""
    filter: TaxRateAggregateFilter
  ): ZoneTaxratesAggregateResponse!
}

input ZoneAggregateFilter {
  and: [ZoneAggregateFilter!]
  or: [ZoneAggregateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type ZoneAggregateResponse {
  count: ZoneCountAggregate
  min: ZoneMinAggregate
  max: ZoneMaxAggregate
}

type ZoneCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
}

input ZoneDeleteFilter {
  and: [ZoneDeleteFilter!]
  or: [ZoneDeleteFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type ZoneDeleteResponse {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input ZoneFilter {
  and: [ZoneFilter!]
  or: [ZoneFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type ZoneMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

type ZoneMembersAggregateResponse {
  count: ZoneMembersCountAggregate
  min: ZoneMembersMinAggregate
  max: ZoneMembersMaxAggregate
}

type ZoneMembersCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  deletedAt: Int
  code: Int
  name: Int
  enabled: Int
}

type ZoneMembersMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
}

type ZoneMembersMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  deletedAt: DateTime
  code: String
  name: String
}

type ZoneMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
}

input ZoneSort {
  field: ZoneSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ZoneSortFields {
  id
  createdAt
  updatedAt
  name
}

type ZoneStoresAggregateResponse {
  count: ZoneStoresCountAggregate
  min: ZoneStoresMinAggregate
  max: ZoneStoresMaxAggregate
}

type ZoneStoresCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  storeName: Int
  phoneNumber: Int
  officialemail: Int
  zipcode: Int
  streetAddress1: Int
  streetAddress2: Int
  GSTIN: Int
  singleStore: Int
  rentalStore: Int
  channelMarkets: Int
  services: Int
  assetAPI: Int
  mainAPI: Int
}

type ZoneStoresMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

type ZoneStoresMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  storeName: String
  phoneNumber: String
  officialemail: String
  zipcode: String
  streetAddress1: String
  streetAddress2: String
  GSTIN: String
  assetAPI: String
  mainAPI: String
}

input ZoneSubscriptionFilter {
  and: [ZoneSubscriptionFilter!]
  or: [ZoneSubscriptionFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

type ZoneTaxratesAggregateResponse {
  count: ZoneTaxratesCountAggregate
  sum: ZoneTaxratesSumAggregate
  avg: ZoneTaxratesAvgAggregate
  min: ZoneTaxratesMinAggregate
  max: ZoneTaxratesMaxAggregate
}

type ZoneTaxratesAvgAggregate {
  value: Float
}

type ZoneTaxratesCountAggregate {
  id: Int
  createdAt: Int
  updatedAt: Int
  name: Int
  value: Int
  enabled: Int
}

type ZoneTaxratesMaxAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

type ZoneTaxratesMinAggregate {
  id: ID
  createdAt: DateTime
  updatedAt: DateTime
  name: String
  value: Float
}

type ZoneTaxratesSumAggregate {
  value: Float
}

input ZoneUpdateFilter {
  and: [ZoneUpdateFilter!]
  or: [ZoneUpdateFilter!]
  id: IDFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: StringFieldComparison
}

